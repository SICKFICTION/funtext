<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ZenText</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Patrick+Hand&family=Kalam:wght@400&family=Caveat:wght@400&family=Dancing+Script:wght@400&display=swap"
        rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/opentype.js@1.3.4/dist/opentype.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            /* Universal box-sizing to prevent overflow issues */
        }

        /* Defensive constraint to prevent horizontal overflow on container elements */
        #controls,
        .control-row,
        .control-group,
        #gradientControls {
            max-width: 100%;
        }

        html,
        body {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            background: #001111;
            display: flex;
            flex-direction: column;
            font-family: 'Patrick Hand', cursive;
            color: #fff;
            overflow: hidden;
            /* Prevent scrollbars */
        }

        #controls {
            padding: 4px;
            background: #e8e6d0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: row;
            gap: 0;
            flex-shrink: 0;
            max-width: 100%;
            box-sizing: border-box;
            transition: all 0.3s ease;
            height: auto;
            min-height: 45px;
            align-items: center;
            justify-content: space-between;
        }

        /* Menu Bar Styles */
        .menu-bar {
            display: flex;
            gap: 0;
            align-items: center;
            flex: 1;
        }

        .menu-item {
            position: relative;
            display: inline-block;
        }

        .menu-label {
            background: #a5a587;
            color: #2d2d1f;
            padding: 6px 10px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border: 1px solid #8b8b70;
            border-right: none;
            transition: all 0.2s ease;
            user-select: none;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
        }

        .menu-item:last-child .menu-label {
            border-right: 1px solid #8b8b70;
        }

        .menu-label:hover {
            background: #7a7a5f;
            color: #1a1a10;
        }

        .menu-label.active {
            background: #7a7a5f;
            color: #1a1a10;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            background: #f5f3e8;
            min-width: 300px;
            max-width: 400px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            top: 100%;
            left: 0;
            border: 1px solid #999;
            border-radius: 0 0 4px 4px;
            padding: 12px;
            max-height: 70vh;
            overflow-y: auto;
            color: #2d2d1f;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
        }

        .dropdown-content.show {
            display: block;
        }

        /* Adjust dropdown position for menu items that would go off screen */
        .menu-item:nth-last-child(-n+3) .dropdown-content {
            right: 0;
            left: auto;
        }

        /* Main inputs in header */
        .main-inputs {
            display: flex;
            gap: 6px;
            align-items: center;
            flex: 1;
            margin: 0 12px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
        }

        .main-inputs input,
        .main-inputs button {
            height: 30px;
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
        }

        .main-inputs label {
            font-size: 0.85rem;
            color: #3d3d2f;
            font-weight: 500;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
        }

        #fromInput {
            width: 150px;
            padding: 6px 8px;
            font-size: 0.9rem;
            border: 1px solid #8b8b70;
            border-radius: 4px;
            background: #f5f3e8;
            color: #2d2d1f;
        }

        #startBtn,
        #shareBtn {
            padding: 6px 12px;
            font-size: 0.9rem;
            cursor: pointer;
            border: 1px solid #8b8b70;
            border-radius: 4px;
            white-space: nowrap;
            background: #a5a587;
            color: #2d2d1f;
            font-weight: 500;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #startBtn:hover,
        #shareBtn:hover {
            background: #7a7a5f;
            color: #1a1a10;
        }

        /* Control styles within dropdowns */
        .control-row {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
            margin-bottom: 8px;
            max-width: 100%;
            box-sizing: border-box;
        }

        .control-row:last-child {
            margin-bottom: 0;
        }



        .control-group {
            display: flex;
            gap: 6px;
            align-items: center;
            flex-shrink: 0;
            /* Prevent shrinking below min-content size */
            max-width: 100%;
            /* Prevent horizontal overflow */
            box-sizing: border-box;
            /* Include padding/margins in width calculations */
        }

        .control-group label {
            font-size: 0.85rem;
            color: #3d3d2f;
            white-space: nowrap;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            font-weight: 500;
        }

        .control-group input[type="range"] {
            width: 80px;
        }

        .control-group select,
        .control-group input[type="color"] {
            padding: 3px;
            background: #fff;
            color: #2d2d1f;
            border: 1px solid #999;
            border-radius: 4px;
            font-size: 0.85rem;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
        }

        /* Gradient color inputs with click-to-toggle styling */
        input[type="color"][id^="gradientColor"] {
            transition: all 0.2s ease;
            border-width: 2px;
        }

        input[type="color"][id^="gradientColor"]:hover:not(:disabled) {
            transform: scale(1.1);
        }

        input[type="color"][id^="gradientColor"]:disabled {
            cursor: pointer !important;
        }

        .control-group span {
            font-size: 0.8rem;
            color: #5d5d4f;
            min-width: 50px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
        }

        /* Music control buttons */
        #musicPlayPause,
        #musicStop {
            padding: 4px 8px;
            font-size: 0.8rem;
            cursor: pointer;
            background: #a5a587;
            color: #2d2d1f;
            border: 1px solid #8b8b70;
            border-radius: 4px;
            margin-right: 4px;
            text-align: center;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            font-weight: 500;
        }

        #musicPlayPause:hover,
        #musicStop:hover {
            background: #7a7a5f;
            color: #1a1a10;
        }

        #musicPlayPause:disabled,
        #musicStop:disabled {
            background: #d5d3c8;
            color: #8b8b70;
            cursor: not-allowed;
        }

        .jitter-group {
            border: 1px solid #999;
            border-radius: 4px;
            padding: 4px 8px;
            background: #eeeede;
        }

        #canvas {
            flex: 1;
            display: block;
            /* background: #001111; */
            /* Removed - will be set by JavaScript */
        }

        /* Fullscreen speed slider */
        #fullscreenSpeedSlider {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1001;
            display: none;
            background: rgba(0, 34, 34, 0.8);
            padding: 10px 15px;
            border-radius: 8px;
            border: 1px solid #333;
            color: #fff;
            font-family: 'Patrick Hand', cursive;
            backdrop-filter: blur(10px);
        }

        #fullscreenSpeedSlider.show {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #fullscreenSpeedSlider label {
            font-size: 0.8rem;
            color: #ccc;
            white-space: nowrap;
        }

        #fullscreenSpeedSlider input[type="range"] {
            width: 80px;
        }

        #fullscreenSpeedSlider span {
            font-size: 0.75rem;
            color: #999;
            min-width: 45px;
        }

        /* Mobile responsive adjustments */
        @media (max-width: 768px) {
            #fullscreenSpeedSlider {
                bottom: 10px;
                right: 10px;
                padding: 8px 12px;
            }

            #fullscreenSpeedSlider label {
                font-size: 0.7rem;
            }

            #fullscreenSpeedSlider input[type="range"] {
                width: 60px;
            }

            #fullscreenSpeedSlider span {
                font-size: 0.7rem;
                min-width: 40px;
            }
        }

        /* Enhanced gradient controls */
        #gradientControls {
            border: 1px solid #999;
            border-radius: 4px;
            padding: 4px 8px;
            background: #eeeede;
            flex-wrap: wrap;
            gap: 4px;
            max-width: 100%;
            /* Prevent horizontal overflow */
            box-sizing: border-box;
            /* Include padding in width calculations */
        }

        #gradientControls input[type="color"] {
            width: 30px;
            height: 20px;
            padding: 0;
            border: 1px solid #999;
            border-radius: 2px;
        }

        #gradientControls input[type="range"] {
            width: 60px;
        }

        /* Message overlay for shared messages */
        #messageOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 17, 17, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        #messageOverlay.hidden {
            display: none;
        }

        #messageButton {
            padding: 20px 40px;
            font-size: 1.2rem;
            background: #a5a587;
            color: #2d2d1f;
            border: 2px solid #8b8b70;
            border-radius: 8px;
            cursor: pointer;
            text-align: center;
            max-width: 80%;
            line-height: 1.4;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            font-weight: 500;
        }

        #messageButton:hover {
            background: #7a7a5f;
            border-color: #6a6a5a;
            color: #1a1a10;
        }



        /* Help button */
        #helpButton {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: #a5a587;
            color: #2d2d1f;
            border: 2px solid #8b8b70;
            font-size: 1.5rem;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
        }

        #helpButton:hover {
            background: #7a7a5f;
            border-color: #6a6a5a;
            color: #1a1a10;
            transform: scale(1.1);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }

        /* Help modal */
        #helpModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            z-index: 2000;
            align-items: center;
            justify-content: center;
            padding: 20px;
            box-sizing: border-box;
        }

        #helpModal.show {
            display: flex;
        }

        .help-content {
            background: #001111;
            border: 2px solid #006666;
            border-radius: 12px;
            padding: 30px;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            color: #fff;
            position: relative;
        }

        .help-content h2 {
            color: #00cccc;
            margin-top: 0;
            text-align: center;
            font-size: 1.8rem;
        }

        .help-content h3 {
            color: #00aaaa;
            margin-top: 25px;
            margin-bottom: 10px;
            font-size: 1.3rem;
        }

        .help-content p,
        .help-content ul {
            line-height: 1.6;
            margin-bottom: 15px;
        }

        .help-content ul {
            padding-left: 20px;
        }

        .help-content li {
            margin-bottom: 8px;
        }

        .help-content .feature {
            background: #002222;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #00cccc;
        }

        .help-content .tip {
            background: #001a1a;
            padding: 12px;
            border-radius: 6px;
            margin: 10px 0;
            font-style: italic;
            border-left: 3px solid #00aa88;
        }

        .donation-section {
            background: #002200;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            text-align: center;
            border: 2px solid #00aa44;
        }

        .donation-section h3 {
            color: #00cc55;
            margin-top: 0;
        }

        .donation-link {
            color: #00ff77;
            text-decoration: none;
            font-weight: bold;
            font-size: 1.1rem;
        }

        .donation-link:hover {
            color: #66ffaa;
            text-decoration: underline;
        }

        #helpCloseButton {
            position: absolute;
            top: 15px;
            right: 20px;
            background: #aa0000;
            color: #fff;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            font-size: 1.2rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #helpCloseButton:hover {
            background: #cc0000;
        }

        /* Detached Text Input Area - Minimized and Inline */
        #detachedTextArea {
            position: fixed;
            top: 4px;
            right: 4px;
            width: 200px;
            height: 37px;
            background: #f5f3e8;
            border: 1px solid #8b8b70;
            border-radius: 4px;
            z-index: 1500;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            transition: all 0.3s ease;
        }

        #detachedTextArea.expanded {
            width: 400px;
            height: 120px;
            top: 60px;
            right: 20px;
            resize: both;
            min-width: 250px;
            min-height: 80px;
            max-width: 90vw;
            max-height: 50vh;
            border: 2px solid #8b8b70;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .text-area-header {
            background: #a5a587;
            color: #2d2d1f;
            padding: 6px 10px;
            cursor: move;
            font-size: 0.75rem;
            font-weight: 500;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            border-bottom: 1px solid #8b8b70;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 25px;
            box-sizing: border-box;
        }

        #detachedTextArea.expanded .text-area-header {
            font-size: 0.8rem;
            padding: 6px 10px;
            height: 30px;
        }

        .text-area-content {
            padding: 6px;
            height: calc(100% - 25px);
            box-sizing: border-box;
            display: none;
        }

        #detachedTextArea.expanded .text-area-content {
            display: block;
            padding: 8px;
            height: calc(100% - 30px);
        }

        #mainTextInput {
            width: 100%;
            height: 100%;
            padding: 4px;
            font-size: 0.85rem;
            border: 1px solid #8b8b70;
            border-radius: 4px;
            background: #fff;
            color: #2d2d1f;
            resize: none;
            font-family: inherit;
            box-sizing: border-box;
            outline: none;
        }

        #detachedTextArea.expanded #mainTextInput {
            padding: 6px;
            font-size: 0.9rem;
        }

        #textAreaToggle {
            background: #7a7a5f;
            color: #f5f3e8;
            border: none;
            border-radius: 3px;
            width: 16px;
            height: 16px;
            font-size: 0.65rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        #detachedTextArea.expanded #textAreaToggle {
            width: 18px;
            height: 18px;
            font-size: 0.7rem;
        }

        #textAreaToggle:hover {
            background: #5a5a4a;
        }

        /* Hide text editor in fullscreen - comprehensive approach */
        body:fullscreen #detachedTextArea,
        body:-webkit-full-screen #detachedTextArea,
        body:-moz-full-screen #detachedTextArea,
        body:-ms-fullscreen #detachedTextArea,
        :fullscreen #detachedTextArea,
        :-webkit-full-screen #detachedTextArea,
        :-moz-full-screen #detachedTextArea,
        :-ms-fullscreen #detachedTextArea {
            display: none !important;
            z-index: -9999 !important;
            visibility: hidden !important;
            opacity: 0 !important;
            pointer-events: none !important;
        }

        /* Hide all textarea and input elements in fullscreen except sliders and help button */
        body:fullscreen textarea,
        body:-webkit-full-screen textarea,
        body:-moz-full-screen textarea,
        body:-ms-fullscreen textarea,
        :fullscreen textarea,
        :-webkit-full-screen textarea,
        :-moz-full-screen textarea,
        :-ms-fullscreen textarea {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
            pointer-events: none !important;
        }
    </style>
</head>

<body>
    <div id="controls">
        <!-- Main inputs in header bar -->
        <div class="main-inputs">
            <input id="fromInput" placeholder="From (your name/email)" />
            <button id="startBtn" disabled>Start</button>
            <button id="shareBtn">Share</button>
            <div class="control-group">
                <label>Speed:</label>
                <input type="range" id="lpmSlider" min="0" max="12" value="4" />
                <span id="lpmValue">16 LPM</span>
            </div>
            <div class="control-group">
                <label>Scale:</label>
                <input type="range" id="zoomSlider" min="0.5" max="10.0" step="0.1" value="7.5" />
                <span id="zoomValue">300px</span>
            </div>
            <div class="control-group">
                <label>
                    <input type="checkbox" id="fullscreenOnStart" />
                    Fullscreen
                </label>
            </div>
        </div>

        <!-- Menu Bar -->
        <div class="menu-bar">
            <div class="menu-item">
                <div class="menu-label">Font & Text</div>
                <div class="dropdown-content">
                    <div class="control-row">
                        <div class="control-group">
                            <label>Font:</label>
                            <select id="fontSelect">
                                <option value="Patrick Hand">Patrick Hand</option>
                                <option value="Kalam">Kalam</option>
                                <option value="Handlee">Handlee</option>
                                <option value="Lobster">Lobster</option>
                                <option value="Architects Daughter">Architects Daughter</option>
                                <option value="Indie Flower">Indie Flower</option>
                                <option value="Amatic SC">Amatic SC</option>
                                <option value="Righteous">Righteous</option>
                                <option value="Pacifico">Pacifico</option>
                                <option value="Courgette">Courgette</option>
                                <option value="Great Vibes">Great Vibes</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label>Weight:</label>
                            <select id="fontWeight">
                                <option value="light">Light</option>
                                <option value="normal">Normal</option>
                                <option value="bold">Bold</option>
                                <option value="heavy">Heavy</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label>Style:</label>
                            <select id="fontStyle">
                                <option value="normal">Normal</option>
                                <option value="italic">Italic</option>
                            </select>
                        </div>
                    </div>
                    <div class="control-row">
                        <div class="control-group">
                            <label>Layout:</label>
                            <select id="layoutMode">
                                <option value="wrap">Wrap</option>
                                <option value="ticker">Ticker</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label>
                                <input type="checkbox" id="tickerLoop" checked />
                                Loop Ticker
                            </label>
                        </div>
                        <div class="control-group">
                            <label>Align:</label>
                            <select id="textAlignment">
                                <option value="left">Left</option>
                                <option value="center">Center</option>
                                <option value="right">Right</option>
                                <option value="justify">Justify</option>
                            </select>
                        </div>
                    </div>
                    <div class="control-row">
                        <div class="control-group">
                            <label>Spacing:</label>
                            <input type="range" id="lineSpacingSlider" min="0" max="10" step="1" value="5" />
                            <span id="lineSpacingValue">300px</span>
                        </div>
                        <div class="control-group">
                            <label>Letter Gap:</label>
                            <input type="range" id="letterSpacingSlider" min="0" max="10" step="1" value="5" />
                            <span id="letterSpacingValue">1.0x</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="menu-item">
                <div class="menu-label">Colors</div>
                <div class="dropdown-content">
                    <div class="control-row">
                        <div class="control-group">
                            <label>Color:</label>
                            <select id="colorMode">
                                <option value="pastel">Pastel</option>
                                <option value="neon">Neon</option>
                                <option value="single">Single</option>
                            </select>
                            <input type="color" id="singleColor" value="#ff69b4" style="display:none;" />
                        </div>
                        <div class="control-group">
                            <label>Fill:</label>
                            <select id="fillMode">
                                <option value="none">None</option>
                                <option value="same">Same as Outline</option>
                                <option value="custom">Custom</option>
                                <option value="neon">Neon Random</option>
                                <option value="pastel">Pastel Random</option>
                                <option value="cycling">Color Cycling</option>
                            </select>
                            <input type="color" id="fillColor" value="#ff69b4" style="display:none;" />
                        </div>
                    </div>
                    <div class="control-row">
                        <div class="control-group">
                            <label>Glow:</label>
                            <input type="range" id="glowSlider" min="0" max="100" step="1" value="100" />
                            <span id="glowValue">100%</span>
                        </div>
                        <div class="control-group">
                            <label>Flicker:</label>
                            <input type="range" id="flickerSlider" min="0" max="100" step="1" value="0" />
                            <span id="flickerValue">0%</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="menu-item">
                <div class="menu-label">Drawing</div>
                <div class="dropdown-content">
                    <div class="control-row">
                        <div class="control-group">
                            <label>
                                <input type="checkbox" id="lineOffMode" />
                                Dot Only
                            </label>
                        </div>
                        <div class="control-group">
                            <label>
                                <input type="checkbox" id="immediateFill" />
                                Immediate Fill
                            </label>
                        </div>
                        <div class="control-group">
                            <label>Dot Size:</label>
                            <input type="range" id="dotSizeSlider" min="5" max="30" step="1" value="11" />
                            <span id="dotSizeValue">11px</span>
                        </div>
                        <div class="control-group">
                            <label>Trail:</label>
                            <input type="range" id="trailSlider" min="0" max="2" step="0.1" value="2.0" />
                            <span id="trailValue">2.0s</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="menu-item">
                <div class="menu-label">Effects</div>
                <div class="dropdown-content">
                    <div class="control-row">
                        <div class="jitter-group">
                            <div class="control-group">
                                <label>Jitter:</label>
                                <input type="range" id="jitterSlider" min="0" max="20" step="0.5" value="0" />
                                <span id="jitterValue">0.0</span>
                            </div>
                            <div class="control-group">
                                <label>Freq:</label>
                                <input type="range" id="jitterFreqSlider" min="0" max="100" step="0.1" value="16" />
                                <span id="jitterFreqValue">16.0</span>
                            </div>
                            <div class="control-group">
                                <label>Shape:</label>
                                <select id="jitterShape">
                                    <option value="sine">Sine</option>
                                    <option value="cosine">Cosine</option>
                                    <option value="triangle">Triangle</option>
                                    <option value="square">Square</option>
                                    <option value="noise">Noise</option>
                                    <option value="abs-sine">Abs-Sine</option>
                                    <option value="sawtooth">Sawtooth</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    <div class="control-row">
                        <div class="jitter-group">
                            <div class="control-group">
                                <label>Path Jitter:</label>
                                <input type="range" id="pathJitterSlider" min="0" max="20" step="0.5" value="0" />
                                <span id="pathJitterValue">0.0</span>
                            </div>
                            <div class="control-group">
                                <label>Freq:</label>
                                <input type="range" id="pathJitterFreqSlider" min="0" max="100" step="0.1" value="16" />
                                <span id="pathJitterFreqValue">16.0</span>
                            </div>
                            <div class="control-group">
                                <label>Shape:</label>
                                <select id="pathJitterShape">
                                    <option value="sine">Sine</option>
                                    <option value="cosine">Cosine</option>
                                    <option value="triangle">Triangle</option>
                                    <option value="square">Square</option>
                                    <option value="noise">Noise</option>
                                    <option value="abs-sine">Abs-Sine</option>
                                    <option value="sawtooth">Sawtooth</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="menu-item">
                <div class="menu-label">Music</div>
                <div class="dropdown-content">
                    <div class="control-row">
                        <div class="control-group">
                            <label>Background Music:</label>
                            <select id="musicSelect">
                                <option value="">None</option>
                                <option value="8 Bit Game.mp3">8 Bit Game</option>
                                <option value="60s Spies.mp3">60s Spies</option>
                                <option value="70s TV Show.mp3">70s TV Show</option>
                                <option value="80s Hiphop.mp3">80s Hiphop</option>
                                <option value="ALIEN ROBOTS.mp3">Alien Robots</option>
                                <option value="ATMOSPHERE.mp3">Atmosphere</option>
                                <option value="Blade Rider.mp3">Blade Rider</option>
                                <option value="Chill Hop Synth.mp3">Chill Hop Synth</option>
                                <option value="CREEPY.mp3">Creepy</option>
                                <option value="CYBERPUNK.mp3">Cyberpunk</option>
                                <option value="DIVE BAR.mp3">Dive Bar</option>
                                <option value="Dixie Jazz.mp3">Dixie Jazz</option>
                                <option value="Eastern.mp3">Eastern</option>
                                <option value="Efficiency.mp3">Efficiency</option>
                                <option value="Electric Cloud.mp3">Electric Cloud</option>
                                <option value="Geektastic.mp3">Geektastic</option>
                                <option value="Hawaiiain.mp3">Hawaiian</option>
                                <option value="JANGLY AMERICAN GUITAR.mp3">Jangly American Guitar</option>
                                <option value="Jerry.mp3">Jerry</option>
                                <option value="Keep On Truckin.mp3">Keep On Truckin</option>
                                <option value="La France.mp3">La France</option>
                                <option value="Oceans 17.mp3">Oceans 17</option>
                                <option value="Oldskool.mp3">Oldskool</option>
                                <option value="Ragtime.mp3">Ragtime</option>
                                <option value="Road Trip Acoustic.mp3">Road Trip Acoustic</option>
                                <option value="Sad Guitar.mp3">Sad Guitar</option>
                                <option value="Sneaky.mp3">Sneaky</option>
                                <option value="Surfin Canadia.mp3">Surfin Canada</option>
                                <option value="War Heroes.mp3">War Heroes</option>
                            </select>
                        </div>
                    </div>
                    <div class="control-row">
                        <div class="control-group">
                            <label>Volume:</label>
                            <input type="range" id="musicVolume" min="0" max="100" step="1" value="50" />
                            <span id="musicVolumeValue">50%</span>
                        </div>
                        <div class="control-group">
                            <label>
                                <input type="checkbox" id="musicLoop" checked />
                                Loop
                            </label>
                        </div>
                    </div>
                    <div class="control-row">
                        <div class="control-group">
                            <button id="musicPlayPause" disabled>Play</button>
                            <button id="musicStop" disabled>Stop</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="menu-item">
                <div class="menu-label">Background</div>
                <div class="dropdown-content">
                    <div class="control-row">
                        <div class="control-group">
                            <label>Background:</label>
                            <select id="backgroundMode">
                                <option value="solid">Solid</option>
                                <option value="linear">Linear</option>
                                <option value="radial">Radial</option>
                                <option value="conic">Conic</option>
                                <option value="cycling">Cycling</option>
                                <option value="boomerang">Boomerang</option>
                            </select>
                            <input type="color" id="backgroundColor" value="#000000" />
                        </div>
                    </div>
                    <div class="control-row" id="gradientControls" style="display:none;">
                        <div class="control-group">
                            <label>Angle:</label>
                            <input type="range" id="gradientAngle" min="0" max="360" step="1" value="135" />
                            <span id="gradientAngleValue">135¬∞</span>
                        </div>
                        <div class="control-group">
                            <label>Colors:</label>
                            <input type="color" id="gradientColor1" value="#000033" />
                            <input type="color" id="gradientColor2" value="#001122" />
                            <input type="color" id="gradientColor3" value="#002211" />
                            <input type="color" id="gradientColor4" value="#112200" />
                            <input type="color" id="gradientColor5" value="#220011" />
                            <input type="color" id="gradientColor6" value="#110022" />
                        </div>
                    </div>
                    <div class="control-row">
                        <div class="control-group">
                            <label>Image/Video URL:</label>
                            <input type="text" id="backgroundImageUrl"
                                placeholder="Enter image/video URL (JPG, PNG, GIF, MP4, WEBM) or YouTube link (video will be muted)"
                                style="width: 250px; padding: 4px; background: #f5f3e8; color: #2d2d1f; border: 1px solid #8b8b70; border-radius: 4px;" />
                        </div>
                    </div>
                    <div class="control-row">
                        <div class="control-group">
                            <small style="color: #888; font-size: 0.85em;">
                                ‚ÑπÔ∏è YouTube videos are auto-muted (browser policy). Use Music menu for audio.
                            </small>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Help Button -->
    <button id="helpButton" title="Help & Instructions">?</button>

    <!-- Help Modal -->
    <div id="helpModal">
        <div class="help-content">
            <button id="helpCloseButton" title="Close">√ó</button>
            <h2>üåü Zen Text - Help & Instructions üåü</h2>

            <div class="feature">
                <h3>‚ú® What is Zen Text?</h3>
                <p>Zen Text helps you focus and read more carefully by displaying text one letter at a time with
                    beautiful handwriting animation. Perfect for kids learning to read, adults who want to slow down and
                    focus, or anyone who wants to enjoy text in a new way!</p>
            </div>

            <h3>üìù Getting Started</h3>
            <ul>
                <li><strong>Type your message:</strong> Enter any text in the text box at the top</li>
                <li><strong>Add a signature:</strong> Put your name in the "From" field</li>
                <li><strong>Click "Start":</strong> Watch your text come to life!</li>
                <li><strong>Share it:</strong> Use the "Share" button to create a link others can enjoy</li>
            </ul>

            <div class="feature">
                <h3>‚ö° Speed & Motion Controls</h3>
                <ul>
                    <li><strong>Speed:</strong> Control how fast letters appear (0-60 letters per minute)</li>
                    <li><strong>Size:</strong> Make text bigger or smaller</li>
                    <li><strong>Trail:</strong> Add a fading trail behind the drawing</li>
                    <li><strong>Dot Size:</strong> Change how thick the handwriting looks</li>
                </ul>
            </div>

            <div class="feature">
                <h3>üé® Handwriting Magic</h3>
                <ul>
                    <li><strong>Jitter:</strong> Add natural handwriting wobble to letters</li>
                    <li><strong>Path Jitter:</strong> Make the writing path more organic and bubble-like</li>
                    <li><strong>Shape:</strong> Choose between sine waves, cosine, or absolute sine for different
                        effects</li>
                    <li><strong>Frequency:</strong> Control how often the wobbles happen</li>
                </ul>
                <div class="tip">üí° Try different jitter combinations to find your perfect handwriting style!</div>
            </div>

            <div class="feature">
                <h3>üé≠ Visual Effects</h3>
                <ul>
                    <li><strong>Colors:</strong> Choose from single colors, rainbow, neon, or pastel palettes</li>
                    <li><strong>Glow:</strong> Add a magical glow around the text</li>
                    <li><strong>Flicker:</strong> Make letters flicker like old neon signs</li>
                    <li><strong>Fill:</strong> Fill letters with colors or leave them as outlines</li>
                </ul>
            </div>

            <div class="feature">
                <h3>üåà Background Magic</h3>
                <ul>
                    <li><strong>Solid Color:</strong> Pick any background color you like</li>
                    <li><strong>Gradient:</strong> Create beautiful color transitions</li>
                    <li><strong>Color Cycling:</strong> Watch colors smoothly change over time</li>
                    <li><strong>Boomerang:</strong> Colors expand and contract from center like breathing</li>
                    <li><strong>Image/Video Backgrounds:</strong> Use JPG, PNG, GIF, MP4, WEBM files or YouTube links as
                        backgrounds</li>
                    <li><strong>YouTube Videos:</strong> YouTube background videos will be muted (browser security
                        policy). Use the Music menu for audio</li>
                    <li><strong>Gradient Colors:</strong> The first two colors are always active. Colors 3-6 start
                        disabled (grayed out)</li>
                    <li><strong>Enable Colors:</strong> Click on grayed out colors to enable them</li>
                    <li><strong>Change Colors:</strong> Click on active colors to pick new colors</li>
                    <li><strong>Disable Colors:</strong> Right-click on active colors to disable them</li>
                </ul>
                <div class="tip">üé® Start with 2 colors, then click to add more gradient colors for complex effects! For
                    video backgrounds with audio, use direct MP4/WEBM links instead of YouTube.</div>
            </div>

            <div class="feature">
                <h3>üéµ Background Music</h3>
                <ul>
                    <li><strong>Music Selection:</strong> Choose from 29 different background tracks including 8-bit,
                        jazz, ambient, and more</li>
                    <li><strong>Auto-Play:</strong> Music automatically starts when you click "Start" or view a shared
                        message</li>
                    <li><strong>Volume Control:</strong> Adjust music volume from 0-100%</li>
                    <li><strong>Loop Option:</strong> Choose whether music repeats continuously</li>
                    <li><strong>Playback Controls:</strong> Play, pause, and stop music independently of the text
                        animation</li>
                    <li><strong>Sharing:</strong> Music selection is included when you share your Zen Text creation</li>
                </ul>
                <div class="tip">üéß Try different music styles to match the mood of your text - ambient for meditation,
                    upbeat for motivation!</div>
            </div>

            <div class="feature">
                <h3>üì± Layout Options</h3>
                <ul>
                    <li><strong>Wrap Mode:</strong> Text flows like a book with multiple lines</li>
                    <li><strong>Ticker Mode:</strong> Text scrolls horizontally like a news ticker</li>
                    <li><strong>Loop Ticker:</strong> When enabled, ticker mode automatically restarts when text scrolls
                        off screen</li>
                    <li><strong>Alignment:</strong> Choose left, center, or right alignment</li>
                    <li><strong>Spacing:</strong> Adjust line and letter spacing for perfect readability</li>
                </ul>
            </div>

            <div class="feature">
                <h3>üî§ Font Styles</h3>
                <ul>
                    <li><strong>Font Family:</strong> Choose from various handwriting and display fonts</li>
                    <li><strong>Weight:</strong> Make text light, normal, or bold</li>
                    <li><strong>Style:</strong> Add italic flair to your text</li>
                </ul>
            </div>

            <div class="feature">
                <h3>üéØ Pro Tips</h3>
                <ul>
                    <li>Use <strong>Line Off Mode</strong> to hide guidelines and focus on the text</li>
                    <li>Try <strong>Fullscreen</strong> for an immersive reading experience</li>
                    <li>Experiment with different <strong>jitter shapes</strong> - each gives a unique feel</li>
                    <li>Combine <strong>glow and flicker</strong> for dramatic neon effects</li>
                    <li>Use <strong>path jitter</strong> to make writing look more natural and hand-drawn</li>
                </ul>
            </div>

            <div class="donation-section">
                <h3>üíñ Support Zen Text</h3>
                <p>If you enjoy Zen Text and find it helpful, consider supporting its development!</p>
                <p>Every donation helps keep this project free and helps me create more useful tools.</p>
                <a href="https://www.paypal.com/paypalme/jamesmulvale" target="_blank" class="donation-link">
                    üéÅ Support via PayPal
                </a>
                <p style="margin-top: 15px; font-size: 0.9rem; opacity: 0.8;">Thank you for being awesome! üåü</p>
            </div>
        </div>
    </div>

    <!-- Detached Text Input Area - Minimized and Inline -->
    <div id="detachedTextArea">
        <div class="text-area-header">
            <span>üìù Text</span>
            <button id="textAreaToggle" title="Expand/Collapse">‚ö°</button>
        </div>
        <div class="text-area-content">
            <textarea id="mainTextInput" placeholder="Paste text here or enter a URL...
(Press Enter for line breaks)">Watch the pen! Calm your mind! Zen Text by sickfiction@gmail.com</textarea>
        </div>
    </div>

    <!-- Message overlay for shared messages -->
    <div id="messageOverlay" class="hidden">
        <button id="messageButton">Click here to open your message</button>
    </div>

    <!-- Fullscreen speed slider -->
    <div id="fullscreenSpeedSlider">
        <label>Speed:</label>
        <input type="range" id="fullscreenLpmSlider" min="0" max="12" value="4" />
        <span id="fullscreenLpmValue">16 LPM</span>
    </div>

    <canvas id="canvas"></canvas>
    <script>        let canvas, ctx, font;
        let baseFontSize = 40, fontSize = 40, baselineY;
        const margin = 50;
        let lettersPerMinute = 16;
        let letterData = []; let scrollOffset = 0;
        let tickerScrollOffset = 0; // Smooth pixel-based ticker scroll offset
        let wrapScrollOffset = 0; // Smooth pixel-based wrap mode vertical scroll offset
        let lastScrollTime = 0; // For delta time calculation in smooth scrolling
        let currentLine = 0; let lineHeight = 300;
        let letterSpacing = 1.0; // Letter spacing multiplier
        let zoomFactor = 1; let isAnimating = false;
        let lineOffMode = false;
        let trailLength = 2.0;
        let dotSize = 11; // Dot size for drawing
        let jitterAmount = 0;
        let jitterFrequency = 16; // Default to 16 MPL (slider value 5)
        let jitterShape = 'sine';
        let pathJitterAmount = 0;
        let pathJitterFrequency = 16; // Default to 16 MPL
        let pathJitterShape = 'sine';
        let trailPoints = []; // Store fading trail points        let glowIntensity = 100;        let flickerProbability = 0;        let backgroundMode = 'solid';
        let backgroundColor = '#001111';
        let gradientColors = ['#000033', '#001122', '#002211', '#112200', '#220011', '#110022'];
        let gradientAngle = 135;
        let fillMode = 'none'; let fillColor = '#ff69b4';
        let cyclingOffset = 0; // For cycling gradients
        let isEnteringFullscreen = false; // Flag to prevent onResize interference
        let globalAnimationStartTime = null; // Global animation timer for continuous jitter
        let layoutMode = 'wrap';
        let textAlignment = 'left';
        let fontWeight = 'normal';
        let fontStyle = 'normal';
        let mainAnimationId = null; // Main animation timeout ID

        // Music variables
        let currentMusic = null; // Current audio element
        let musicVolume = 0.5; // Default volume (50%)
        let musicLoop = true; // Default loop enabled
        let isPlaying = false; // Track play state

        // Ticker loop variable
        let tickerLoop = true; // Default ticker loop enabled

        // Immediate fill variable
        let immediateFill = false; // Default immediate fill disabled

        // Background image/video variables
        let backgroundImageUrl = ''; // Background image/video URL
        let backgroundMedia = null; // Background media element (img or video)

        const pastelColors = [
            '#FFB3BA', '#FFDFBA', '#FFFFBA', '#BAFFC9',
            '#BAE1FF', '#D4BAFF', '#FFBAEF', '#FFCBA4',
            '#C7CEEA', '#FFD1DC', '#E6E6FA', '#F0E68C',
            '#98FB98', '#F5DEB3', '#DDA0DD', '#FFE4E1'
        ];

        const neonColors = [
            '#FF0080', '#00FF80', '#8000FF', '#FF8000',
            '#0080FF', '#80FF00', '#FF0040', '#40FF00',
            '#0040FF', '#FF4000', '#00FF40', '#4000FF',
            '#FF0000', '#00FF00', '#0000FF', '#FFFF00',
            '#FF00FF', '#00FFFF', '#FF8080', '#80FF80'
        ];

        function initializeDropdownMenus() {
            const menuLabels = document.querySelectorAll('.menu-label');

            // Add click event listeners to menu labels
            menuLabels.forEach(label => {
                label.addEventListener('click', function (e) {
                    e.stopPropagation();

                    const menuItem = this.parentElement;
                    const dropdown = menuItem.querySelector('.dropdown-content');
                    const wasOpen = dropdown.classList.contains('show');

                    // Close all other dropdowns
                    document.querySelectorAll('.dropdown-content').forEach(d => {
                        d.classList.remove('show');
                    });
                    document.querySelectorAll('.menu-label').forEach(l => {
                        l.classList.remove('active');
                    });

                    // Toggle current dropdown
                    if (!wasOpen) {
                        dropdown.classList.add('show');
                        this.classList.add('active');
                    }
                });
            });

            // Close dropdowns when clicking outside
            document.addEventListener('click', function (e) {
                if (!e.target.closest('.menu-item')) {
                    document.querySelectorAll('.dropdown-content').forEach(dropdown => {
                        dropdown.classList.remove('show');
                    });
                    document.querySelectorAll('.menu-label').forEach(label => {
                        label.classList.remove('active');
                    });
                }
            });

            // Prevent dropdown from closing when clicking inside it
            document.querySelectorAll('.dropdown-content').forEach(dropdown => {
                dropdown.addEventListener('click', function (e) {
                    e.stopPropagation();
                });
            });
        }

        async function init() {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            window.addEventListener('resize', onResize);
            onResize();

            // Parse URL parameters and set text input
            parseUrlParameters();

            // Set initial font size based on screen size
            setInitialFontSize();

            await loadFont('Patrick Hand');

            document.getElementById('startBtn').addEventListener('click', toggleAnimation);
            document.getElementById('lpmSlider').addEventListener('input', updateLPM);
            document.getElementById('fullscreenLpmSlider').addEventListener('input', updateFullscreenLPM);
            document.getElementById('lineOffMode').addEventListener('change', updateLineOffMode);
            document.getElementById('trailSlider').addEventListener('input', updateTrailLength);
            document.getElementById('dotSizeSlider').addEventListener('input', updateDotSize); document.getElementById('jitterSlider').addEventListener('input', updateJitter);
            document.getElementById('jitterFreqSlider').addEventListener('input', updateJitterFrequency);
            document.getElementById('jitterShape').addEventListener('change', updateJitterShape);
            document.getElementById('pathJitterSlider').addEventListener('input', updatePathJitter);
            document.getElementById('pathJitterFreqSlider').addEventListener('input', updatePathJitterFrequency);
            document.getElementById('pathJitterShape').addEventListener('change', updatePathJitterShape);
            document.getElementById('zoomSlider').addEventListener('input', updateZoom);
            document.getElementById('fontSelect').addEventListener('change', changeFont); document.getElementById('colorMode').addEventListener('change', toggleColorMode); document.getElementById('glowSlider').addEventListener('input', updateGlow);
            document.getElementById('flickerSlider').addEventListener('input', updateFlicker); document.getElementById('lineSpacingSlider').addEventListener('input', updateLineSpacing);
            document.getElementById('letterSpacingSlider').addEventListener('input', updateLetterSpacing); document.getElementById('backgroundMode').addEventListener('change', updateBackgroundMode);
            document.getElementById('backgroundColor').addEventListener('input', updateBackgroundColor);
            document.getElementById('gradientAngle').addEventListener('input', updateGradientAngle);
            document.getElementById('gradientColor1').addEventListener('input', updateGradientColorAndVisibility);
            document.getElementById('gradientColor2').addEventListener('input', updateGradientColorAndVisibility);
            document.getElementById('gradientColor3').addEventListener('input', updateGradientColorAndVisibility);
            document.getElementById('gradientColor4').addEventListener('input', updateGradientColorAndVisibility);
            document.getElementById('gradientColor5').addEventListener('input', updateGradientColorAndVisibility);
            document.getElementById('gradientColor6').addEventListener('input', updateGradientColorAndVisibility);

            document.getElementById('fillMode').addEventListener('change', updateFillMode);
            document.getElementById('fillColor').addEventListener('input', updateFillMode);
            document.getElementById('shareBtn').addEventListener('click', shareSettings);
            document.getElementById('layoutMode').addEventListener('change', updateLayoutMode);
            document.getElementById('textAlignment').addEventListener('change', updateTextAlignment);
            document.getElementById('fontWeight').addEventListener('change', updateFontWeight); document.getElementById('fontStyle').addEventListener('change', updateFontStyle);

            // Music event listeners
            document.getElementById('musicSelect').addEventListener('change', updateMusicSelection);
            document.getElementById('musicVolume').addEventListener('input', updateMusicVolume);
            document.getElementById('musicLoop').addEventListener('change', updateMusicLoop);
            document.getElementById('musicPlayPause').addEventListener('click', toggleMusicPlayPause);
            document.getElementById('musicStop').addEventListener('click', stopMusic);

            // Ticker loop event listener
            document.getElementById('tickerLoop').addEventListener('change', updateTickerLoop);

            // Immediate fill event listener
            document.getElementById('immediateFill').addEventListener('change', updateImmediateFill);

            // Background image URL event listener
            document.getElementById('backgroundImageUrl').addEventListener('input', updateBackgroundImageUrl);

            // Detached Text Area functionality
            const mainTextInput = document.getElementById('mainTextInput');
            const detachedTextArea = document.getElementById('detachedTextArea');
            const textAreaToggle = document.getElementById('textAreaToggle');
            const textAreaHeader = document.querySelector('.text-area-header');

            // Make text area draggable
            let isDragging = false;
            let dragOffsetX = 0;
            let dragOffsetY = 0;

            textAreaHeader.addEventListener('mousedown', function (e) {
                if (e.target === textAreaToggle) return; // Don't drag when clicking toggle button
                isDragging = true;
                dragOffsetX = e.clientX - detachedTextArea.offsetLeft;
                dragOffsetY = e.clientY - detachedTextArea.offsetTop;
                document.addEventListener('mousemove', handleDrag);
                document.addEventListener('mouseup', stopDrag);
                e.preventDefault();
            });

            function handleDrag(e) {
                if (!isDragging) return;
                detachedTextArea.style.left = (e.clientX - dragOffsetX) + 'px';
                detachedTextArea.style.top = (e.clientY - dragOffsetY) + 'px';
            }

            function stopDrag() {
                isDragging = false;
                document.removeEventListener('mousemove', handleDrag);
                document.removeEventListener('mouseup', stopDrag);
            }

            // Toggle text area collapsed/expanded
            textAreaToggle.addEventListener('click', function () {
                detachedTextArea.classList.toggle('expanded');
                const isExpanded = detachedTextArea.classList.contains('expanded');
                textAreaToggle.textContent = isExpanded ? '‚úï' : '‚ö°';
                textAreaToggle.title = isExpanded ? 'Collapse' : 'Expand';

                if (isExpanded) {
                    // Focus the textarea when expanded
                    setTimeout(() => mainTextInput.focus(), 100);
                }
            });

            // Initialize dropdown menus
            initializeDropdownMenus();

            updateLPM();
            updateZoom();
            updateDotSize();
            updateJitter();
            updateJitterFrequency();
            updateJitterShape();
            updatePathJitter();
            updatePathJitterFrequency();
            updatePathJitterShape();
            updateGlow();
            updateFlicker(); updateLineSpacing();
            updateLetterSpacing(); updateBackgroundMode();
            updateLayoutMode();
            updateTextAlignment();
            updateFontWeight();
            updateFontStyle();
            updateFillMode();
            setupAdvancedSliderInteraction(); // Setup advanced slider interaction for all sliders

            // Apply initial background mode and color visibility
            updateBackgroundMode(); // This will show/hide gradient controls
            updateGradientColorVisibility();
            updateBackgroundColor();

            // Initialize music controls
            updateMusicVolume();
            updateMusicLoop();
            updateTickerLoop();
            updateImmediateFill();
            updateBackgroundImageUrl();
        }

        function setInitialFontSize() {
            const isMobile = window.innerWidth <= 768 || window.innerHeight <= 768;

            if (isMobile) {
                // Mobile default: 50px (scale 1.25)
                baseFontSize = 40;
                document.getElementById('zoomSlider').value = '1.25';
                document.getElementById('zoomSlider').min = '0.5';   // Min 20px
                document.getElementById('zoomSlider').max = '10.0';  // Max 400px
            } else {
                // Desktop default: 300px (scale 7.5)
                baseFontSize = 40;
                document.getElementById('zoomSlider').value = '7.5';
                document.getElementById('zoomSlider').min = '0.5';   // Min 20px
                document.getElementById('zoomSlider').max = '10.0';  // Max 400px
            }
        }

        async function loadFont(fontName) {
            const fontUrls = {
                'Patrick Hand': 'https://cdn.jsdelivr.net/gh/google/fonts@main/ofl/patrickhand/PatrickHand-Regular.ttf',
                'Kalam': 'https://cdn.jsdelivr.net/gh/google/fonts@main/ofl/kalam/Kalam-Regular.ttf',
                'Handlee': 'https://cdn.jsdelivr.net/gh/google/fonts@main/ofl/handlee/Handlee-Regular.ttf',
                'Lobster': 'https://cdn.jsdelivr.net/gh/google/fonts@main/ofl/lobster/Lobster-Regular.ttf',
                'Architects Daughter': 'https://cdn.jsdelivr.net/gh/google/fonts@main/ofl/architectsdaughter/ArchitectsDaughter-Regular.ttf',
                'Indie Flower': 'https://cdn.jsdelivr.net/gh/google/fonts@main/ofl/indieflower/IndieFlower-Regular.ttf',
                'Amatic SC': 'https://cdn.jsdelivr.net/gh/google/fonts@main/ofl/amaticsc/AmaticSC-Regular.ttf',
                'Righteous': 'https://cdn.jsdelivr.net/gh/google/fonts@main/ofl/righteous/Righteous-Regular.ttf',
                'Pacifico': 'https://cdn.jsdelivr.net/gh/google/fonts@main/ofl/pacifico/Pacifico-Regular.ttf',
                'Courgette': 'https://cdn.jsdelivr.net/gh/google/fonts@main/ofl/courgette/Courgette-Regular.ttf',
                'Great Vibes': 'https://cdn.jsdelivr.net/gh/google/fonts@main/ofl/greatvibes/GreatVibes-Regular.ttf'
            };

            try {
                const resp = await fetch(fontUrls[fontName]);
                const buf = await resp.arrayBuffer();
                const newFont = opentype.parse(buf);

                // Validate that the font loaded correctly and has the expected name
                if (newFont && newFont.names && newFont.names.fontFamily) {
                    font = newFont;
                    console.log(`Font loaded successfully: ${fontName}`);
                    document.getElementById('startBtn').disabled = false;
                } else {
                    throw new Error('Font validation failed');
                }
            } catch (e) {
                console.error('Font load failed for', fontName, e);
                alert(`Could not load vector font: ${fontName}. Please try a different font.`);
                // Keep the previous font if loading fails
                document.getElementById('startBtn').disabled = false;
            }
        } async function toggleAnimation() {
            if (isAnimating) {
                // Stop animation
                isAnimating = false;
                if (mainAnimationId) {
                    clearTimeout(mainAnimationId);
                    cancelAnimationFrame(mainAnimationId);
                    mainAnimationId = null;
                }
                globalAnimationStartTime = null; // Reset global timer
                document.getElementById('startBtn').textContent = 'Start';
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                letterData = [];
                scrollOffset = 0;
                wrapScrollOffset = 0;
                tickerScrollOffset = 0;
                lastScrollTime = 0;
                currentLine = 0;
                trailPoints = []; // Clear trail points
                stopFlickerAnimation(); // Stop flicker animation if running
                stopTickerAnimation(); // Stop ticker animation if running

                // Stop music when animation stops
                if (currentMusic && isPlaying) {
                    stopMusic();
                }
            } else {
                // Start animation
                trailPoints = []; // Clear trail points before starting

                // Start music if selected and not already playing
                if (currentMusic && !isPlaying) {
                    toggleMusicPlayPause();
                }

                await startReveal();
            }
        } function updateLPM() {
            const sliderValue = parseInt(document.getElementById('lpmSlider').value);
            // Map slider value (0-10) to logarithmic LPM scale (powers of 2: 1,2,4,...,4096)
            const lpmValues = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096];
            lettersPerMinute = lpmValues[sliderValue];
            document.getElementById('lpmValue').textContent = lettersPerMinute + ' LPM';

            // Sync with fullscreen slider
            document.getElementById('fullscreenLpmSlider').value = sliderValue;
            document.getElementById('fullscreenLpmValue').textContent = lettersPerMinute + ' LPM';
        }

        function updateFullscreenLPM() {
            const sliderValue = parseInt(document.getElementById('fullscreenLpmSlider').value);
            // Map slider value (0-10) to logarithmic LPM scale (powers of 2: 1,2,4,...,4096)
            const lpmValues = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096];
            lettersPerMinute = lpmValues[sliderValue];
            document.getElementById('fullscreenLpmValue').textContent = lettersPerMinute + ' LPM';

            // Sync with main slider
            document.getElementById('lpmSlider').value = sliderValue;
            document.getElementById('lpmValue').textContent = lettersPerMinute + ' LPM';
        }

        function updateLineOffMode() {
            lineOffMode = document.getElementById('lineOffMode').checked;
            // Clear trail points when mode changes
            trailPoints = [];
        } function updateTrailLength() {
            const value = document.getElementById('trailSlider').value;
            trailLength = parseFloat(value);
            document.getElementById('trailValue').textContent = value + 's';
            // Clear existing trail points when length changes
            trailPoints = [];
        }

        function updateDotSize() {
            const value = document.getElementById('dotSizeSlider').value;
            dotSize = parseInt(value);
            document.getElementById('dotSizeValue').textContent = value + 'px';
        }

        function updateJitter() {
            const value = document.getElementById('jitterSlider').value;
            jitterAmount = parseFloat(value);
            document.getElementById('jitterValue').textContent = value;
        } function updateJitterFrequency() {
            const sliderValue = parseFloat(document.getElementById('jitterFreqSlider').value);

            // Store the MPL directly as a decimal value from 0 to 100
            jitterFrequency = sliderValue;

            document.getElementById('jitterFreqValue').textContent = sliderValue.toFixed(1);
        }
        function updateJitterShape() {
            jitterShape = document.getElementById('jitterShape').value;
        } function updatePathJitter() {
            const value = document.getElementById('pathJitterSlider').value;
            pathJitterAmount = parseFloat(value);
            document.getElementById('pathJitterValue').textContent = value;
            // Recalculate path jitter offsets for all revealed letters
            recalculatePathJitterOffsets();
        }

        function updatePathJitterFrequency() {
            const sliderValue = parseFloat(document.getElementById('pathJitterFreqSlider').value);
            pathJitterFrequency = sliderValue;
            document.getElementById('pathJitterFreqValue').textContent = sliderValue.toFixed(1);
            // Recalculate path jitter offsets for all revealed letters
            recalculatePathJitterOffsets();
        }

        function updatePathJitterShape() {
            pathJitterShape = document.getElementById('pathJitterShape').value;
            // Recalculate path jitter offsets for all revealed letters
            recalculatePathJitterOffsets();
        } function updateLineSpacing() {
            const sliderValue = parseInt(document.getElementById('lineSpacingSlider').value);
            // Logarithmic scale for line spacing: 100, 150, 200, 250, 300, 350, 400, 500, 600, 800, 1000
            const spacingValues = [100, 150, 200, 250, 300, 350, 400, 500, 600, 800, 1000];
            const baseSpacing = spacingValues[sliderValue];

            // Calculate line height based on font size and spacing multiplier
            lineHeight = fontSize * (baseSpacing / 300); // 300 is the default
            document.getElementById('lineSpacingValue').textContent = Math.round(lineHeight) + 'px';

            // If we have text loaded, regenerate the paths with new spacing
            if (letterData.length > 0) {
                regenerateLetterPaths();
            }
        }

        function updateLetterSpacing() {
            const sliderValue = parseInt(document.getElementById('letterSpacingSlider').value);
            // Linear scale for letter spacing: 0.5x to 2.0x
            const spacingValues = [0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2, 1.4, 1.7, 2.0];
            letterSpacing = spacingValues[sliderValue];
            document.getElementById('letterSpacingValue').textContent = letterSpacing.toFixed(1) + 'x';

            // If we have text loaded, regenerate the paths with new spacing
            if (letterData.length > 0) {
                regenerateLetterPaths();
            }
        }

        // Helper function to convert hex to rgba with opacity
        function hexToRgba(hex, opacity) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${opacity})`;
        }

        // Helper function to interpolate between two hex colors
        function interpolateColors(color1, color2, t) {
            // Parse hex colors
            const r1 = parseInt(color1.slice(1, 3), 16);
            const g1 = parseInt(color1.slice(3, 5), 16);
            const b1 = parseInt(color1.slice(5, 7), 16);

            const r2 = parseInt(color2.slice(1, 3), 16);
            const g2 = parseInt(color2.slice(3, 5), 16);
            const b2 = parseInt(color2.slice(5, 7), 16);

            // Interpolate
            const r = Math.round(r1 + (r2 - r1) * t);
            const g = Math.round(g1 + (g2 - g1) * t);
            const b = Math.round(b1 + (b2 - b1) * t);

            // Convert back to hex
            return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
        }

        // Music Functions
        function updateMusicSelection() {
            const selectedMusic = document.getElementById('musicSelect').value;

            // Stop current music if playing
            if (currentMusic) {
                currentMusic.pause();
                currentMusic = null;
                isPlaying = false;
                updatePlayPauseButton();
            }

            // Enable/disable control buttons
            const hasMusic = selectedMusic !== '';
            document.getElementById('musicPlayPause').disabled = !hasMusic;
            document.getElementById('musicStop').disabled = !hasMusic;

            if (hasMusic) {
                // Create new audio element
                currentMusic = new Audio(selectedMusic);
                currentMusic.volume = musicVolume;
                currentMusic.loop = musicLoop;

                // Add event listeners
                currentMusic.addEventListener('ended', function () {
                    if (!musicLoop) {
                        isPlaying = false;
                        updatePlayPauseButton();
                    }
                });

                currentMusic.addEventListener('error', function () {
                    console.error('Error loading music file:', selectedMusic);
                    alert('Could not load music file. Please check that the file exists.');
                });
            }
        }

        function updateMusicVolume() {
            const value = document.getElementById('musicVolume').value;
            musicVolume = parseFloat(value) / 100;
            document.getElementById('musicVolumeValue').textContent = value + '%';

            if (currentMusic) {
                currentMusic.volume = musicVolume;
            }
        }

        function updateMusicLoop() {
            musicLoop = document.getElementById('musicLoop').checked;
            if (currentMusic) {
                currentMusic.loop = musicLoop;
            }
        }

        function updateTickerLoop() {
            tickerLoop = document.getElementById('tickerLoop').checked;
        }

        function updateImmediateFill() {
            immediateFill = document.getElementById('immediateFill').checked;
        }

        function updateBackgroundImageUrl() {
            backgroundImageUrl = document.getElementById('backgroundImageUrl').value.trim();

            // Remove existing background media
            if (backgroundMedia) {
                if (backgroundMedia.parentNode) {
                    backgroundMedia.parentNode.removeChild(backgroundMedia);
                }
                backgroundMedia = null;
            }

            if (backgroundImageUrl) {
                // Check if it's a YouTube URL
                const youtubeMatch = backgroundImageUrl.match(/(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([a-zA-Z0-9_-]{11})/);

                if (youtubeMatch) {
                    // Handle YouTube video
                    const videoId = youtubeMatch[1];
                    backgroundMedia = document.createElement('iframe');
                    backgroundMedia.src = `https://www.youtube.com/embed/${videoId}?autoplay=1&mute=1&loop=1&playlist=${videoId}&controls=0&showinfo=0&rel=0&iv_load_policy=3&modestbranding=1&disablekb=1&fs=0`;
                    backgroundMedia.allow = 'autoplay; encrypted-media';
                    backgroundMedia.style.border = 'none';

                    // Style the iframe to replace CSS background
                    backgroundMedia.style.position = 'fixed';
                    backgroundMedia.style.top = '0';
                    backgroundMedia.style.left = '0';
                    backgroundMedia.style.width = '100%';
                    backgroundMedia.style.height = '100%';
                    backgroundMedia.style.zIndex = '-1';
                    backgroundMedia.style.pointerEvents = 'none'; // Prevent interaction

                    // Clear CSS background immediately for YouTube videos
                    document.body.style.background = 'transparent';

                    // Add to document body
                    document.body.insertBefore(backgroundMedia, document.body.firstChild);
                } else {
                    // Determine if it's a video or image based on file extension
                    const isVideo = /\.(mp4|webm|ogg|mov|avi)$/i.test(backgroundImageUrl);

                    if (isVideo) {
                        // Create video element
                        backgroundMedia = document.createElement('video');
                        backgroundMedia.src = backgroundImageUrl;
                        backgroundMedia.autoplay = true;
                        backgroundMedia.loop = true;
                        backgroundMedia.muted = true; // Required for autoplay
                        backgroundMedia.playsInline = true;
                    } else {
                        // Create image element
                        backgroundMedia = document.createElement('img');
                        backgroundMedia.src = backgroundImageUrl;
                    }

                    // Style the background media to replace CSS background
                    backgroundMedia.style.position = 'fixed';
                    backgroundMedia.style.top = '0';
                    backgroundMedia.style.left = '0';
                    backgroundMedia.style.width = '100%';
                    backgroundMedia.style.height = '100%';
                    backgroundMedia.style.objectFit = 'cover';
                    backgroundMedia.style.zIndex = '-1';

                    // Add error handling
                    backgroundMedia.onerror = function () {
                        console.error('Failed to load background media:', backgroundImageUrl);
                        if (backgroundMedia && backgroundMedia.parentNode) {
                            backgroundMedia.parentNode.removeChild(backgroundMedia);
                        }
                        backgroundMedia = null;
                        // Restore CSS background when media fails
                        updateBackgroundColor();
                    };

                    // On successful load, clear CSS background
                    backgroundMedia.onload = backgroundMedia.onloadeddata = function () {
                        // Clear CSS background when image/video loads successfully
                        document.body.style.background = 'transparent';
                    };

                    // Add to document body
                    document.body.insertBefore(backgroundMedia, document.body.firstChild);

                    // For videos, try to play
                    if (isVideo) {
                        backgroundMedia.play().catch(function (error) {
                            console.warn('Video autoplay failed:', error);
                        });
                    }
                }
            } else {
                // No background image/video URL, restore CSS background
                updateBackgroundColor();
            }
        }

        function toggleMusicPlayPause() {
            if (!currentMusic) return;

            if (isPlaying) {
                currentMusic.pause();
                isPlaying = false;
            } else {
                currentMusic.play().catch(function (error) {
                    console.error('Error playing music:', error);
                    alert('Could not play music. Please try again.');
                });
                isPlaying = true;
            }
            updatePlayPauseButton();
        }

        function stopMusic() {
            if (currentMusic) {
                currentMusic.pause();
                currentMusic.currentTime = 0;
                isPlaying = false;
                updatePlayPauseButton();
            }
        }

        function updatePlayPauseButton() {
            const button = document.getElementById('musicPlayPause');
            button.textContent = isPlaying ? 'Pause' : 'Play';
        }

        function updateBackgroundMode() {
            backgroundMode = document.getElementById('backgroundMode').value;
            const gradientControls = document.getElementById('gradientControls');

            // Stop cycling gradient if switching away from cycling/boomerang
            if (backgroundMode !== 'cycling' && backgroundMode !== 'boomerang') {
                stopCyclingGradient();
            }

            if (backgroundMode === 'solid') {
                gradientControls.style.display = 'none';
            } else {
                gradientControls.style.display = 'flex';
                // Initialize gradient color visibility
                updateGradientColorVisibility();
            }

            // Update angle slider label based on mode
            updateGradientAngle();

            updateBackgroundColor();

            // Start cycling gradient if selected
            if (backgroundMode === 'cycling' || backgroundMode === 'boomerang') {
                startCyclingGradient();
            }
        }

        function updateGradientColorAndVisibility() {
            updateBackgroundColor();
            updateGradientColorVisibility();
        }

        function updateGradientColorVisibility() {
            const colorInputs = [
                document.getElementById('gradientColor1'),
                document.getElementById('gradientColor2'),
                document.getElementById('gradientColor3'),
                document.getElementById('gradientColor4'),
                document.getElementById('gradientColor5'),
                document.getElementById('gradientColor6')
            ];

            // Initialize enabled state if not set
            if (!colorInputs[0].hasAttribute('data-enabled')) {
                // First two colors enabled by default (makes sense for gradients)
                colorInputs[0].setAttribute('data-enabled', 'true');
                colorInputs[1].setAttribute('data-enabled', 'true');
                // Colors 3-6 disabled by default
                for (let i = 2; i < colorInputs.length; i++) {
                    colorInputs[i].setAttribute('data-enabled', 'false');
                }
            }

            // Apply visual styling and event handlers
            for (let i = 0; i < colorInputs.length; i++) {
                const element = colorInputs[i];
                let isEnabled = element.getAttribute('data-enabled') === 'true';

                // Force first two colors to always be enabled
                if (i < 2) {
                    isEnabled = true;
                    element.setAttribute('data-enabled', 'true');
                }

                if (isEnabled) {
                    element.style.opacity = '1';
                    element.style.border = '2px solid #555';
                    element.disabled = false;
                } else {
                    element.style.opacity = '0.3';
                    element.style.border = '2px solid #222';
                    element.disabled = false;
                }

                // Add tooltips for all gradient colors
                if (i < 2) {
                    element.title = 'Always enabled gradient color - click to change';
                }

                // Add click handler for toggling (only for colors 3-6)
                if (i >= 2) {
                    element.style.cursor = 'pointer';
                    element.title = isEnabled ?
                        'Click to change color, right-click to disable' :
                        'Click to enable this gradient color';

                    // Remove any existing event listeners to prevent duplicates
                    element.onclick = null;
                    element.removeEventListener('click', element._clickHandler);
                    element.removeEventListener('contextmenu', element._rightClickHandler);

                    // Create new click handler and store reference for removal
                    element._clickHandler = function (e) {
                        const currentEnabled = element.getAttribute('data-enabled') === 'true';

                        if (!currentEnabled) {
                            // First click: Enable the color
                            e.preventDefault();
                            e.stopPropagation();

                            element.setAttribute('data-enabled', 'true');
                            element.style.opacity = '1';
                            element.style.border = '2px solid #555';

                            // Update background immediately
                            updateBackgroundColor();
                        }
                        // If enabled, let the color picker open normally (don't prevent default)
                    };

                    // Right-click handler to disable color
                    element._rightClickHandler = function (e) {
                        e.preventDefault();
                        e.stopPropagation();

                        const currentEnabled = element.getAttribute('data-enabled') === 'true';
                        if (currentEnabled) {
                            element.setAttribute('data-enabled', 'false');
                            element.style.opacity = '0.3';
                            element.style.border = '2px solid #222';

                            // Update background immediately
                            updateBackgroundColor();
                        }
                    };

                    element.addEventListener('click', element._clickHandler);
                    element.addEventListener('contextmenu', element._rightClickHandler);
                }
            }
        }

        function updateGradientAngle() {
            const value = document.getElementById('gradientAngle').value;
            gradientAngle = parseInt(value);

            if (backgroundMode === 'cycling' || backgroundMode === 'boomerang') {
                // In cycling/boomerang mode, angle controls speed (0-2 cycles per second)
                const speedValue = (value * 2 / 360).toFixed(1);
                document.getElementById('gradientAngleValue').textContent = speedValue + ' c/s';
            } else {
                document.getElementById('gradientAngleValue').textContent = value + '¬∞';
            }

            updateBackgroundColor();
        }

        function updateBackgroundColor() {
            backgroundColor = document.getElementById('backgroundColor').value;

            // Create gradient colors array starting with background color
            const allGradientColors = [
                document.getElementById('gradientColor1').value,
                document.getElementById('gradientColor2').value,
                document.getElementById('gradientColor3').value,
                document.getElementById('gradientColor4').value,
                document.getElementById('gradientColor5').value,
                document.getElementById('gradientColor6').value
            ];            // Build gradient colors: only use enabled gradient colors (start with just 2 colors)
            gradientColors = [];

            for (let i = 0; i < allGradientColors.length; i++) {
                const colorInput = document.getElementById(`gradientColor${i + 1}`);
                const isEnabled = colorInput.getAttribute('data-enabled') === 'true';
                if (isEnabled) {
                    gradientColors.push(allGradientColors[i]);
                }
            }

            // Ensure at least 2 colors for gradient (background + first gradient color)
            if (gradientColors.length === 0) {
                gradientColors = [backgroundColor, allGradientColors[0]]; // Background + first gradient color
            } else if (gradientColors.length === 1) {
                gradientColors.unshift(backgroundColor); // Add background color at start
            }

            let backgroundValue;

            if (backgroundMode === 'solid') {
                backgroundValue = backgroundColor;
            } else if (backgroundMode === 'linear') {
                const colorStops = gradientColors.map((color, index) =>
                    `${color} ${(index * 100 / (gradientColors.length - 1))}%`
                ).join(', ');
                backgroundValue = `linear-gradient(${gradientAngle}deg, ${colorStops})`;
            } else if (backgroundMode === 'radial') {
                const colorStops = gradientColors.map((color, index) =>
                    `${color} ${(index * 100 / (gradientColors.length - 1))}%`
                ).join(', ');
                backgroundValue = `radial-gradient(circle at center, ${colorStops})`;
            } else if (backgroundMode === 'conic') {
                const colorStops = gradientColors.map((color, index) =>
                    `${color} ${(index * 360 / gradientColors.length)}deg`
                ).join(', ');
                backgroundValue = `conic-gradient(from ${gradientAngle}deg at center, ${colorStops})`;
            } else if (backgroundMode === 'cycling') {
                // Cycling mode: expanding rings with smooth color transitions from center
                const speed = gradientAngle * 2 / 360; // Map 0-360 to 0-2 cycles per second
                const timeScale = performance.now() / 1000 * speed; // Convert to seconds and apply speed

                const totalColors = gradientColors.length;
                if (totalColors === 1) {
                    backgroundValue = `radial-gradient(circle at center, ${gradientColors[0]} 0%, ${gradientColors[0]} 100%)`;
                } else {
                    // Create expanding rings - each ring represents a moment in time
                    const ringSpacing = 3; // Pixels between each ring
                    const maxRadius = Math.sqrt(canvas.width * canvas.width + canvas.height * canvas.height) / 2;
                    const totalRings = Math.ceil(maxRadius / ringSpacing);

                    // Time-based animation - each ring is born at center and expands
                    const animationTime = timeScale * 100; // Scale for ring creation rate

                    const colorStops = [];

                    // Generate rings from center outward
                    for (let ring = 0; ring < totalRings; ring++) {
                        const ringRadius = ring * ringSpacing;
                        const ringBirthTime = animationTime - ring; // When this ring was "born"

                        if (ringBirthTime >= 0) {
                            // Determine which color phase this ring is in
                            const colorCycle = ringBirthTime / 50; // Adjust speed of color transition
                            const colorProgress = colorCycle % totalColors;

                            const currentColorIndex = Math.floor(colorProgress) % totalColors;
                            const nextColorIndex = (currentColorIndex + 1) % totalColors;
                            const blend = colorProgress - Math.floor(colorProgress);

                            // Interpolate between current and next color
                            const currentColor = gradientColors[currentColorIndex];
                            const nextColor = gradientColors[nextColorIndex];
                            const ringColor = interpolateColors(currentColor, nextColor, blend);

                            // Convert radius to percentage
                            const radiusPercent = Math.min((ringRadius / maxRadius) * 100, 100);

                            if (radiusPercent <= 100) {
                                colorStops.push({
                                    color: ringColor,
                                    radius: radiusPercent
                                });
                            }
                        }
                    }

                    // Sort by radius
                    colorStops.sort((a, b) => a.radius - b.radius);

                    // Build gradient string
                    const gradientStops = colorStops.map(stop =>
                        `${stop.color} ${stop.radius.toFixed(1)}%`);

                    // Ensure we have a center point
                    if (gradientStops.length === 0) {
                        gradientStops.push(`${gradientColors[0]} 0%`);
                    }

                    backgroundValue = `radial-gradient(circle at center, ${gradientStops.join(', ')})`;
                }
            } else if (backgroundMode === 'boomerang') {
                // Boomerang effect - expand from center to full screen, then contract back
                const speed = gradientAngle * 2 / 360; // Map 0-360 to 0-2 cycles per second
                const timeScale = performance.now() / 1000 * speed; // Convert to seconds and apply speed

                const totalColors = gradientColors.length;
                const cycle = timeScale % 1; // 0 to 1 cycle

                // Simple breathing/boomerang effect
                let expansionFactor;
                if (cycle < 0.5) {
                    // First half: expand from 0 to 1 (0% to 100%)
                    expansionFactor = cycle * 2; // 0 to 1
                } else {
                    // Second half: contract from 1 to 0 (100% back to 0%)
                    expansionFactor = 2 - (cycle * 2); // 1 to 0
                }

                const colorStops = [];

                // Create expanding gradient with all colors
                for (let i = 0; i < totalColors; i++) {
                    // Each color gets a position in the gradient
                    const basePosition = (i / (totalColors - 1)) * 100; // 0% to 100%
                    const expandedPosition = basePosition * expansionFactor;

                    colorStops.push(`${gradientColors[i]} ${expandedPosition.toFixed(1)}%`);
                }

                // Ensure final color extends to current expansion limit
                if (expansionFactor > 0) {
                    const finalPosition = 100 * expansionFactor;
                    colorStops[colorStops.length - 1] = `${gradientColors[totalColors - 1]} ${finalPosition.toFixed(1)}%`;
                }

                backgroundValue = `radial-gradient(circle at center, ${colorStops.join(', ')})`;
            }

            // Only apply CSS background if there's no background image/video URL
            if (!backgroundImageUrl) {
                document.body.style.background = backgroundValue;
            }

            if (canvas) {
                // Make canvas transparent to show body background gradient
                canvas.style.background = 'transparent';
            }

            // Update color visibility after color change (only if not in solid mode)
            if (backgroundMode !== 'solid') {
                // Don't call updateGradientColorVisibility here to prevent recursion
            }
        }        // Cycling gradient animation
        let cyclingAnimationId = null;

        function startCyclingGradient() {
            if (cyclingAnimationId) return; // Already running

            function cyclingLoop() {
                if (backgroundMode === 'cycling' || backgroundMode === 'boomerang') {
                    // Update background at 60fps for smooth animation
                    updateBackgroundColor();
                    cyclingAnimationId = requestAnimationFrame(cyclingLoop);
                } else {
                    cyclingAnimationId = null;
                }
            }

            if (backgroundMode === 'cycling' || backgroundMode === 'boomerang') {
                cyclingAnimationId = requestAnimationFrame(cyclingLoop);
            }
        }
        function stopCyclingGradient() {
            if (cyclingAnimationId) {
                cancelAnimationFrame(cyclingAnimationId);
                cyclingAnimationId = null;
            }
        }

        function updateFillMode() {
            fillMode = document.getElementById('fillMode').value;
            fillColor = document.getElementById('fillColor').value;

            const fillColorInput = document.getElementById('fillColor');
            if (fillMode === 'custom') {
                fillColorInput.style.display = 'inline-block';
            } else {
                fillColorInput.style.display = 'none';
            }
        } function updateLayoutMode() {
            layoutMode = document.getElementById('layoutMode').value;

            // Stop ticker animation if switching away from ticker
            if (layoutMode !== 'ticker') {
                stopTickerAnimation();
            }

            // Reset scroll offsets when changing layout modes
            wrapScrollOffset = 0;
            tickerScrollOffset = 0;
            lastScrollTime = 0;

            // Show/hide alignment controls based on layout mode
            const alignmentGroup = document.getElementById('textAlignment').parentElement;
            if (layoutMode === 'ticker') {
                alignmentGroup.style.display = 'none';
            } else {
                alignmentGroup.style.display = 'flex';
            }

            // If we have text loaded, regenerate the paths with new layout
            if (letterData.length > 0) {
                regenerateLetterPaths();
                redrawCurrentState();

                // Start ticker if needed
                if (layoutMode === 'ticker') {
                    startTickerIfNeeded();
                }
            }
        }

        function updateTextAlignment() {
            textAlignment = document.getElementById('textAlignment').value;

            // If we have text loaded, regenerate the paths with new alignment
            if (letterData.length > 0) {
                regenerateLetterPaths();
                redrawCurrentState();
            }
        }

        function updateFontWeight() {
            fontWeight = document.getElementById('fontWeight').value;

            // If we have text loaded, regenerate the paths with new weight
            if (letterData.length > 0) {
                regenerateLetterPaths();
                redrawCurrentState();
            }
        }

        function updateFontStyle() {
            fontStyle = document.getElementById('fontStyle').value;

            // If we have text loaded, regenerate the paths with new style
            if (letterData.length > 0) {
                regenerateLetterPaths();
                redrawCurrentState();
            }
        }

        // Function to calculate line thickness based on font weight
        function getLineThickness() {
            // Ensure thickness never exceeds negative space in characters
            const maxThickness = Math.max(2, fontSize * 0.015); // Max 1.5% of font size

            switch (fontWeight) {
                case 'light':
                    return Math.max(1, maxThickness * 0.5);
                case 'normal':
                    return Math.max(2, maxThickness * 0.75);
                case 'bold':
                    return maxThickness;
                case 'heavy':
                    return maxThickness;
                default:
                    return Math.max(2, maxThickness * 0.75);
            }
        }        // Function to apply italic transformation to path points
        function applyItalicTransform(points, italicAngle = -0.2) {
            if (fontStyle !== 'italic') return points;

            return points.map(point => ({
                ...point,
                x: point.x + (point.y - baselineY) * italicAngle
            }));
        }

        // Function to calculate text alignment offset
        function getAlignmentOffset(lineWidth, canvasWidth) {
            if (layoutMode === 'ticker') return 0;

            switch (textAlignment) {
                case 'center':
                    // Center text considering margins on both sides
                    const availableWidth = canvasWidth - 2 * margin;
                    return Math.max(0, (availableWidth - lineWidth) / 2);
                case 'right':
                    return Math.max(0, canvasWidth - lineWidth - 2 * margin);
                case 'justify':
                    return 0; // Handled separately in justify logic
                default: // left
                    return 0;
            }
        }        // Function to handle ticker mode positioning
        function getTickerPosition(time, totalWidth) {
            if (layoutMode !== 'ticker') return 0;

            // Text scrolls left while pen stays in center
            const speed = 50; // pixels per second
            const scrollDistance = (time / 1000) * speed;

            // Start text from right side of screen, scroll left
            const startX = canvas.width; // Start from right edge

            return startX - scrollDistance;
        }
        async function startReveal() {
            let text = document.getElementById('mainTextInput').value.trim();
            if (!text) {
                console.log('No text to reveal - returning early');
                return;
            }

            console.log('Starting reveal with text:', text.substring(0, 50) + '...');

            if (!font) {
                console.error('Font not loaded - cannot proceed');
                alert('Font not loaded. Please wait for font to load and try again.');
                return;
            }

            // Stop flicker animation during main animation
            stopFlickerAnimation();

            // Stop continuous jitter animation during main animation
            stopContinuousJitterAnimation();

            // Check if fullscreen on start is enabled
            const fullscreenOnStart = document.getElementById('fullscreenOnStart').checked; if (fullscreenOnStart) {
                await enterFullscreen();
                // After fullscreen, make sure we have the correct canvas dimensions
                if (canvas) {
                    console.log('Fullscreen activated, canvas size:', canvas.width, 'x', canvas.height);
                }
            }            // Clear canvas and reset all state variables AFTER fullscreen is set
            if (canvas && ctx) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
            scrollOffset = 0;
            wrapScrollOffset = 0; // Reset wrap scroll offset
            tickerScrollOffset = 0; // Reset ticker scroll offset
            lastScrollTime = 0; // Reset scroll timing
            letterData = [];
            trailPoints = [];

            // Initialize global animation timer for continuous jitter
            globalAnimationStartTime = performance.now();

            // Check if input is a URL
            if (text.startsWith('http://') || text.startsWith('https://') || text.startsWith('www.')) {
                try {
                    document.getElementById('startBtn').textContent = 'Loading...';

                    const extractedText = await extractTextFromUrl(text);
                    if (extractedText && extractedText.length > 10) {
                        text = extractedText;
                        console.log('Extracted text:', text.substring(0, 100) + '...');
                    } else {
                        alert('Could not extract meaningful text from URL. Please try a different URL or paste text directly.');
                        isAnimating = false;
                        document.getElementById('startBtn').textContent = 'Start';
                        return;
                    }
                } catch (e) {
                    console.error('Error fetching URL:', e);
                    alert('Error fetching URL. Please check the URL or try pasting text directly.');
                    isAnimating = false;
                    document.getElementById('startBtn').textContent = 'Start';
                    return;
                }
            }            // Pre-calculate word wrapping with current font and canvas size
            // First handle explicit line breaks, then split words
            const textLines = text.split(/\r?\n/); // Split on line breaks first
            let layoutText = '';
            let x = margin;
            let y = baselineY;
            currentLine = 0;

            // Ensure we use the current line height calculation
            const currentLineSpacing = parseInt(document.getElementById('lineSpacingSlider').value);
            const spacingValues = [100, 150, 200, 250, 300, 350, 400, 500, 600, 800, 1000];
            const baseSpacing = spacingValues[currentLineSpacing];
            lineHeight = fontSize * (baseSpacing / 300); console.log('Text layout - Canvas:', canvas.width, 'x', canvas.height, 'Font size:', fontSize, 'Line height:', lineHeight);

            if (layoutMode === 'ticker') {
                // Ticker mode: Never wrap, keep all text on single line, join lines with spaces
                layoutText = textLines.join(' ');
            } else {
                // Wrap mode: Process each line separately, respecting explicit line breaks
                for (let lineIndex = 0; lineIndex < textLines.length; lineIndex++) {
                    const line = textLines[lineIndex];
                    const words = line.split(/\s+/).filter(word => word.length > 0);

                    // If this is not the first line, force a line break
                    if (lineIndex > 0) {
                        // Force line break by moving to next line
                        x = margin;
                        y += lineHeight;
                        currentLine++;
                        layoutText += '\n'; // Add explicit line break marker
                    }

                    // Process words in this line
                    for (let word of words) {
                        // Calculate word width
                        let wordWidth = 0;
                        for (let char of word) {
                            const glyph = font.charToGlyph(char) || font.charToGlyph(' ');
                            wordWidth += glyph.advanceWidth * (fontSize / font.unitsPerEm) * letterSpacing;
                        }

                        // Check if word fits on current line (but not if we just started a new explicit line)
                        if (x + wordWidth > canvas.width - margin && x > margin) {
                            // Move to next line
                            x = margin;
                            y += lineHeight;
                            currentLine++;
                            layoutText += '\n'; // Add line break marker
                        }

                        // Add word to layout
                        layoutText += word;
                        if (word !== words[words.length - 1] || lineIndex < textLines.length - 1) {
                            layoutText += ' ';
                        }
                        x += wordWidth + (font.charToGlyph(' ').advanceWidth * (fontSize / font.unitsPerEm) * letterSpacing);
                    }
                }
            }            // Precalculate line widths and starting positions for alignment
            const lines = [];
            let currentLineChars = [];
            let currentLineWidth = 0;
            let lineIndex = 0;

            // First pass: calculate line widths
            let tempX = margin;
            for (let i = 0; i < layoutText.length; i++) {
                const ch = layoutText[i];

                // Handle explicit line breaks
                if (ch === '\n') {
                    // End current line
                    lines.push({
                        chars: currentLineChars,
                        width: currentLineWidth,
                        lineIndex: lineIndex
                    });

                    // Start new line
                    currentLineChars = [];
                    currentLineWidth = 0;
                    tempX = margin;
                    lineIndex++;
                    continue; // Skip processing the \n character
                }

                const glyph = font.charToGlyph(ch) || font.charToGlyph(' ');
                const w = glyph.advanceWidth * (fontSize / font.unitsPerEm) * letterSpacing;

                // Check if we need to wrap (only in wrap mode, never in ticker mode)
                if (layoutMode !== 'ticker' && ch === ' ') {
                    // Look ahead to see if next word fits
                    let nextWordEnd = i + 1;
                    while (nextWordEnd < layoutText.length && layoutText[nextWordEnd] !== ' ' && layoutText[nextWordEnd] !== '\n') {
                        nextWordEnd++;
                    }

                    let nextWordWidth = 0;
                    for (let j = i + 1; j < nextWordEnd; j++) {
                        const nextGlyph = font.charToGlyph(layoutText[j]) || font.charToGlyph(' ');
                        nextWordWidth += nextGlyph.advanceWidth * (fontSize / font.unitsPerEm) * letterSpacing;
                    }

                    if (tempX + nextWordWidth > canvas.width - margin) {
                        // End current line
                        lines.push({
                            chars: currentLineChars,
                            width: currentLineWidth,
                            lineIndex: lineIndex
                        });

                        // Start new line
                        currentLineChars = [];
                        currentLineWidth = 0;
                        tempX = margin;
                        lineIndex++;
                    }
                }

                currentLineChars.push({
                    char: ch,
                    width: w,
                    charIndex: i
                });
                currentLineWidth += w;
                tempX += w;
            }

            // Add the last line
            if (currentLineChars.length > 0) {
                lines.push({
                    chars: currentLineChars,
                    width: currentLineWidth,
                    lineIndex: lineIndex
                });
            }

            // Calculate starting X position for each line based on alignment
            lines.forEach(line => {
                if (layoutMode === 'ticker') {
                    line.startX = margin;
                } else {
                    switch (textAlignment) {
                        case 'center':
                            const availableWidth = canvas.width - 2 * margin;
                            line.startX = margin + Math.max(0, (availableWidth - line.width) / 2);
                            break;
                        case 'right':
                            line.startX = Math.max(margin, canvas.width - line.width - margin);
                            break;
                        case 'justify':
                            line.startX = margin;
                            // Calculate extra spacing for justify (except last line)
                            if (line.lineIndex < lines.length - 1) {
                                const spaceCount = line.chars.filter(c => c.char === ' ').length;
                                if (spaceCount > 0) {
                                    const availableWidth = canvas.width - 2 * margin;
                                    const extraSpace = Math.max(0, availableWidth - line.width);
                                    line.extraSpacePerSpace = extraSpace / spaceCount;
                                } else {
                                    line.extraSpacePerSpace = 0;
                                }
                            } else {
                                line.extraSpacePerSpace = 0; // Don't justify last line
                            }
                            break;
                        default: // left
                            line.startX = margin;
                            break;
                    }
                }
            });

            // Now create letter data with proper positioning
            x = margin;
            y = baselineY;
            currentLine = 0;
            let currentLineData = lines[0];
            let charIndexInLine = 0;
            let extraSpaceAccumulated = 0;

            for (let i = 0; i < layoutText.length; i++) {
                const ch = layoutText[i];

                // Handle explicit line breaks
                if (ch === '\n') {
                    currentLine++;
                    if (currentLine < lines.length) {
                        currentLineData = lines[currentLine];
                        charIndexInLine = 0;
                        extraSpaceAccumulated = 0;
                        x = currentLineData.startX; // Apply alignment for new line
                        y += lineHeight;
                    }
                    continue; // Skip processing the \n character
                }

                // Check if we've moved to a new line (automatic wrapping)
                if (currentLineData && charIndexInLine >= currentLineData.chars.length) {
                    currentLine++;
                    if (currentLine < lines.length) {
                        currentLineData = lines[currentLine];
                        charIndexInLine = 0;
                        extraSpaceAccumulated = 0;
                        x = currentLineData.startX; // Apply alignment for new line
                        y += lineHeight;
                    }
                }

                // Set initial position for first character of each line
                if (charIndexInLine === 0 && currentLineData) {
                    x = currentLineData.startX;
                }

                const glyph = font.charToGlyph(ch) || font.charToGlyph(' ');
                const w = glyph.advanceWidth * (fontSize / font.unitsPerEm) * letterSpacing;

                // Add extra space for justify alignment
                if (textAlignment === 'justify' && currentLineData && currentLineData.extraSpacePerSpace && ch === ' ') {
                    extraSpaceAccumulated += currentLineData.extraSpacePerSpace;
                }

                const path = glyph.getPath(x + extraSpaceAccumulated, y, fontSize);
                const pts = samplePathWithCornerDetection(path.commands);

                // Create Path2D object for filled rendering
                const path2D = new Path2D();
                path.commands.forEach(cmd => {
                    switch (cmd.type) {
                        case 'M':
                            path2D.moveTo(cmd.x, cmd.y);
                            break;
                        case 'L':
                            path2D.lineTo(cmd.x, cmd.y);
                            break;
                        case 'Q':
                            path2D.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);
                            break;
                        case 'C':
                            path2D.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
                            break;
                        case 'Z':
                            path2D.closePath();
                            break;
                    }
                });

                // Assign color based on color mode
                let color;
                const colorMode = document.getElementById('colorMode').value;
                if (colorMode === 'single') {
                    color = document.getElementById('singleColor').value;
                } else if (colorMode === 'neon') {
                    color = neonColors[i % neonColors.length];
                } else {
                    color = pastelColors[i % pastelColors.length];
                }

                // Create letter data for ALL characters including spaces
                letterData.push({
                    char: ch,
                    pts: pts,
                    path: path2D,
                    x: x + extraSpaceAccumulated,
                    y: y,
                    line: currentLine,
                    color: color,
                    revealed: false,
                    currentPointIndex: 0, // Track drawing progress
                    drawingComplete: false,
                    isSpace: ch === ' ' // Flag to identify spaces
                });

                x += w;
                charIndexInLine++;
            }

            console.log('Created letterData array with', letterData.length, 'letters');
            if (letterData.length > 0) {
                console.log('First letter:', letterData[0]);
                console.log('Last letter:', letterData[letterData.length - 1]);
            }

            // Draw all text immediately so it's visible before animation starts
            redrawCurrentState();

            // Now start the animation
            isAnimating = true;
            document.getElementById('startBtn').textContent = 'Stop';

            // Start the main animation loop
            let currentLetterIndex = 0;
            let animationFrameId = null;

            function animateDrawing() {
                console.log('animateDrawing called, currentLetterIndex:', currentLetterIndex, 'isAnimating:', isAnimating);

                if (!isAnimating || currentLetterIndex >= letterData.length) {
                    isAnimating = false;
                    document.getElementById('startBtn').textContent = 'Start';
                    mainAnimationId = null;

                    // Start ticker animation if in ticker mode
                    if (layoutMode === 'ticker') {
                        startTickerIfNeeded();
                    } else if (hasActiveFillAnimations()) {
                        // Start fill animation loop for non-ticker modes
                        startFillAnimationLoop();
                    }

                    // Start flicker animation if enabled
                    startFlickerAnimation();

                    // Start continuous jitter animation if jitter is enabled
                    startContinuousJitterAnimation();
                    return;
                } const currentLetter = letterData[currentLetterIndex];
                if (!currentLetter.revealed) {
                    currentLetter.revealed = true;
                    // Calculate and store path jitter offsets when letter is first revealed
                    if (pathJitterAmount > 0 && currentLetter.pts && currentLetter.pts.length > 0) {
                        currentLetter.pathJitterOffsets = calculatePathJitterOffsetsForLetter(currentLetter, currentLetterIndex);
                    }
                }// Handle letters (including spaces) progressively
                if (currentLetter.pts && currentLetter.pts.length > 0) {
                    // Letter with actual drawing points
                    if (immediateFill) {
                        // Immediate fill: complete the entire letter instantly
                        currentLetter.currentPointIndex = currentLetter.pts.length;
                        currentLetter.drawingComplete = true;
                        currentLetterIndex++;

                        // Skip delay in ticker mode for continuous motion
                        if (layoutMode === 'ticker') {
                            // Continue immediately in ticker mode for smooth scrolling
                            animationFrameId = requestAnimationFrame(animateDrawing);
                            return;
                        }

                        // Add minimal delay for immediate fill in wrap mode
                        const immediateDelayFrames = Math.max(1, Math.floor((60000 / lettersPerMinute / 8) / 16)); // Shorter delay
                        let delayFrameCount = 0;

                        function immediateDelayWithJitter() {
                            if (!isAnimating) return;

                            redrawCurrentState();
                            delayFrameCount++;

                            if (delayFrameCount >= immediateDelayFrames) {
                                animationFrameId = requestAnimationFrame(animateDrawing);
                            } else {
                                animationFrameId = requestAnimationFrame(immediateDelayWithJitter);
                            }
                        }

                        animationFrameId = requestAnimationFrame(immediateDelayWithJitter);
                        return;
                    } else {
                        // Progressive fill: draw letter progressively
                        // Use current lettersPerMinute value for real-time speed updates
                        const currentPointsPerFrame = Math.max(1, Math.floor(lettersPerMinute / 60));
                        const targetPoints = Math.min(
                            currentLetter.currentPointIndex + currentPointsPerFrame,
                            currentLetter.pts.length
                        );

                        // Advance the drawing
                        currentLetter.currentPointIndex = targetPoints;                    // Check if current letter is complete
                        if (currentLetter.currentPointIndex >= currentLetter.pts.length) {
                            currentLetter.drawingComplete = true;
                            currentLetterIndex++;

                            // Skip delay in ticker mode for continuous motion
                            if (layoutMode === 'ticker') {
                                // Continue immediately in ticker mode for smooth scrolling
                                animationFrameId = requestAnimationFrame(animateDrawing);
                                return;
                            }

                            // Continue jitter animation during delay between letters (wrap mode only)
                            let delayFrameCount = 0;
                            // Use current lettersPerMinute for delay calculation
                            const totalDelayFrames = Math.max(1, Math.floor((60000 / lettersPerMinute / 4) / 16)); // ~16ms per frame

                            function delayWithJitter() {
                                if (!isAnimating) return; // Stop if animation was cancelled

                                redrawCurrentState(); // Keep jitter going during delay
                                delayFrameCount++;

                                if (delayFrameCount >= totalDelayFrames) {
                                    // Delay complete, continue with next letter
                                    animationFrameId = requestAnimationFrame(animateDrawing);
                                } else {
                                    // Continue delay with jitter
                                    animationFrameId = requestAnimationFrame(delayWithJitter);
                                }
                            }

                            // Start the delay with continued jitter
                            animationFrameId = requestAnimationFrame(delayWithJitter);
                            return;
                        }
                    }
                } else {
                    // Space or character with no points - mark as complete and move to next immediately
                    currentLetter.drawingComplete = true;
                    currentLetterIndex++;
                    // No delay for spaces - continue immediately for smooth scrolling
                }

                // Redraw the canvas
                redrawCurrentState();

                // Continue animation
                animationFrameId = requestAnimationFrame(animateDrawing);
            }            // Start the animation
            mainAnimationId = requestAnimationFrame(animateDrawing);
        } // End of startReveal function

        // Flicker animation loop
        let flickerAnimationId = null;
        let continuousJitterAnimationId = null;

        function startFlickerAnimation() {
            if (flickerAnimationId) return; // Already running

            function flickerLoop() {
                if (flickerProbability > 0 && letterData.length > 0 && !isAnimating) {
                    redrawCurrentState();
                    flickerAnimationId = requestAnimationFrame(flickerLoop);
                } else {
                    flickerAnimationId = null;
                }
            }

            if (flickerProbability > 0) {
                flickerAnimationId = requestAnimationFrame(flickerLoop);
            }
        }

        function startContinuousJitterAnimation() {
            if (continuousJitterAnimationId) return; // Already running

            function jitterLoop() {
                if (letterData.length > 0 && !isAnimating && jitterAmount > 0) {
                    redrawCurrentState();
                    continuousJitterAnimationId = requestAnimationFrame(jitterLoop);
                } else {
                    continuousJitterAnimationId = null;
                }
            }

            if (jitterAmount > 0) {
                continuousJitterAnimationId = requestAnimationFrame(jitterLoop);
            }
        }

        function stopFlickerAnimation() {
            if (flickerAnimationId) {
                cancelAnimationFrame(flickerAnimationId);
                flickerAnimationId = null;
            }
        }

        function stopContinuousJitterAnimation() {
            if (continuousJitterAnimationId) {
                cancelAnimationFrame(continuousJitterAnimationId);
                continuousJitterAnimationId = null;
            }
        }

        async function changeFont() {
            const fontName = document.getElementById('fontSelect').value;
            document.getElementById('startBtn').disabled = true;
            await loadFont(fontName);

            // Regenerate paths and redraw immediately to show changes
            if (letterData.length > 0) {
                regenerateLetterPaths();
                redrawCurrentState();
            }

            document.getElementById('startBtn').disabled = false;
        }

        function toggleColorMode() {
            const mode = document.getElementById('colorMode').value;
            const singleColor = document.getElementById('singleColor');
            singleColor.style.display = mode === 'single' ? 'inline' : 'none';
        }
        // Caesar cipher functions for message encryption/decryption
        function caesarCipher(text, shift) {
            return text.split('').map(char => {
                const code = char.charCodeAt(0);

                // Uppercase letters A-Z (65-90)
                if (code >= 65 && code <= 90) {
                    return String.fromCharCode(((code - 65 + shift + 26) % 26) + 65);
                }
                // Lowercase letters a-z (97-122)
                else if (code >= 97 && code <= 122) {
                    return String.fromCharCode(((code - 97 + shift + 26) % 26) + 97);
                }
                // Numbers 0-9 (48-57)
                else if (code >= 48 && code <= 57) {
                    return String.fromCharCode(((code - 48 + shift + 10) % 10) + 48);
                }
                // Punctuation and special characters (32-47, 58-64, 91-96, 123-126)
                else if ((code >= 32 && code <= 47) || (code >= 58 && code <= 64) ||
                    (code >= 91 && code <= 96) || (code >= 123 && code <= 126)) {
                    // Create array of all punctuation/special chars in printable ASCII range
                    const punctuation = ' !"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~';
                    const index = punctuation.indexOf(char);
                    if (index !== -1) {
                        const newIndex = (index + shift + punctuation.length) % punctuation.length;
                        return punctuation[newIndex];
                    }
                }
                // Return unchanged if not in our cipher ranges
                return char;
            }).join('');
        }

        function encryptMessage(text) {
            if (!text) return text;
            const ciphered = caesarCipher(text, 1); // Shift forward by 1
            // Use Base64 encoding to ensure URL safety
            return btoa(encodeURIComponent(ciphered));
        }

        function decryptMessage(text) {
            if (!text) return text;
            try {
                // Decode Base64 first, then decrypt
                const decoded = decodeURIComponent(atob(text));
                return caesarCipher(decoded, -1); // Shift backward by 1
            } catch (e) {
                console.warn('Failed to decrypt message, returning as-is:', e);
                return text; // Return original if decryption fails
            }
        } function shareSettings() {
            try {                // Get all current settings
                const settings = parseAllSettings();

                // Create URL with all parameters
                const baseUrl = window.location.origin + window.location.pathname;
                const params = new URLSearchParams();

                Object.keys(settings).forEach(key => {
                    if (settings[key] !== null && settings[key] !== '') {
                        params.append(key, settings[key]);
                    }
                });

                const shareUrl = baseUrl + '?' + params.toString();// Copy to clipboard
                navigator.clipboard.writeText(shareUrl).then(() => {
                    alert('Settings URL copied to clipboard! Share this link to let others see the exact same configuration and it will auto-start the animation.');
                }).catch(err => {
                    // Fallback for older browsers
                    const textArea = document.createElement('textarea');
                    textArea.value = shareUrl;
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                    alert('Settings URL copied to clipboard! Share this link to let others see the exact same configuration and it will auto-start the animation.');
                });
            } catch (error) {
                console.error('Error sharing settings:', error);
                alert('Error creating share URL. Please try again.');
            }
        } function enterFullscreen() {
            return new Promise((resolve) => {
                if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.mozFullScreenElement && !document.msFullscreenElement) {
                    isEnteringFullscreen = true;

                    // Try different fullscreen APIs for browser compatibility
                    const docElement = document.documentElement;
                    let fullscreenPromise;

                    if (docElement.requestFullscreen) {
                        fullscreenPromise = docElement.requestFullscreen();
                    } else if (docElement.webkitRequestFullscreen) {
                        fullscreenPromise = docElement.webkitRequestFullscreen();
                    } else if (docElement.mozRequestFullScreen) {
                        fullscreenPromise = docElement.mozRequestFullScreen();
                    } else if (docElement.msRequestFullscreen) {
                        fullscreenPromise = docElement.msRequestFullscreen();
                    }

                    if (fullscreenPromise) {
                        fullscreenPromise.then(() => {
                            // Hide controls in fullscreen
                            document.getElementById('controls').style.display = 'none';
                            // Show fullscreen speed slider
                            document.getElementById('fullscreenSpeedSlider').classList.add('show');                            // Wait for fullscreen transition and then manually resize
                            setTimeout(() => {
                                // Ensure canvas is initialized before accessing it
                                if (canvas) {
                                    // Manually set canvas size since onResize might not work properly during transition
                                    canvas.width = window.innerWidth;
                                    canvas.height = window.innerHeight;
                                    baselineY = canvas.height * 0.5;
                                    console.log('Fullscreen activated successfully, canvas size:', canvas.width, 'x', canvas.height);

                                    // Apply gradient background immediately in fullscreen
                                    updateBackgroundColor();
                                } else {
                                    console.warn('Canvas not initialized yet, calling onResize instead');
                                    onResize();
                                }

                                isEnteringFullscreen = false;
                                resolve();
                            }, 300);
                        }).catch(err => {
                            isEnteringFullscreen = false;
                            console.error('Error attempting to enable fullscreen:', err);
                            alert('Fullscreen failed. This might be due to browser security restrictions. Please click the fullscreen button manually or try a different browser.');
                            resolve(); // Continue even if fullscreen fails
                        });
                    } else {
                        // Fallback: fullscreen not supported
                        isEnteringFullscreen = false;
                        console.warn('Fullscreen API not supported');
                        alert('Fullscreen is not supported in this browser. The animation will start in normal mode.');
                        resolve();
                    }
                } else {
                    resolve(); // Already in fullscreen
                }
            });
        }        // Listen for fullscreen changes (ESC key, etc.) - handle all browser variants
        document.addEventListener('fullscreenchange', handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
        document.addEventListener('mozfullscreenchange', handleFullscreenChange);
        document.addEventListener('MSFullscreenChange', handleFullscreenChange);

        function handleFullscreenChange() {
            const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement ||
                document.mozFullScreenElement || document.msFullscreenElement);

            const controls = document.getElementById('controls');
            const detachedTextArea = document.getElementById('detachedTextArea');

            if (!isFullscreen) {
                // Exited fullscreen
                controls.style.display = 'flex';
                document.getElementById('fullscreenSpeedSlider').classList.remove('show');
                document.getElementById('fullscreenOnStart').checked = false;

                // Show the detached text area again
                if (detachedTextArea) {
                    detachedTextArea.style.display = '';
                    detachedTextArea.style.visibility = '';
                    detachedTextArea.style.opacity = '';
                    detachedTextArea.style.zIndex = '';
                    detachedTextArea.style.pointerEvents = '';
                }

                // Apply background (image/video takes precedence over CSS background)
                if (backgroundImageUrl) {
                    updateBackgroundImageUrl();
                } else {
                    updateBackgroundColor();
                }

                onResize();
            } else {
                // Entered fullscreen
                document.getElementById('fullscreenSpeedSlider').classList.add('show');

                // Completely hide the detached text area in fullscreen
                if (detachedTextArea) {
                    detachedTextArea.style.display = 'none';
                    detachedTextArea.style.visibility = 'hidden';
                    detachedTextArea.style.opacity = '0';
                    detachedTextArea.style.zIndex = '-9999';
                    detachedTextArea.style.pointerEvents = 'none';
                }

                // Apply background (image/video or gradient) immediately
                if (backgroundImageUrl) {
                    updateBackgroundImageUrl();
                } else {
                    updateBackgroundColor();
                }
            }
        }

        // Add keyboard event listener for F12 key to toggle fullscreen
        document.addEventListener('keydown', function (event) {
            // F12 key (keyCode 123 or key 'F12')
            if (event.key === 'F12' || event.keyCode === 123) {
                event.preventDefault(); // Prevent default F12 behavior (dev tools)

                const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement ||
                    document.mozFullScreenElement || document.msFullscreenElement);

                if (isFullscreen) {
                    // Exit fullscreen
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    } else if (document.webkitExitFullscreen) {
                        document.webkitExitFullscreen();
                    } else if (document.mozCancelFullScreen) {
                        document.mozCancelFullScreen();
                    } else if (document.msExitFullscreen) {
                        document.msExitFullscreen();
                    }
                } else {
                    // Enter fullscreen
                    document.getElementById('fullscreenOnStart').checked = true;
                    enterFullscreen().then(() => {
                        // Show fullscreen speed slider
                        document.getElementById('fullscreenSpeedSlider').classList.add('show');
                    }).catch(err => {
                        console.error('F12 fullscreen failed:', err);
                    });
                }
            }
        });

        function onResize() {
            // Don't interfere if we're in the middle of entering fullscreen
            if (isEnteringFullscreen) {
                return;
            }

            canvas.width = window.innerWidth;

            // Check if we're in fullscreen mode
            const controls = document.getElementById('controls');
            if (document.fullscreenElement) {
                canvas.height = window.innerHeight;
            } else {
                canvas.height = window.innerHeight - controls.offsetHeight;
            }

            // Improved baseline calculation for better centering
            baselineY = fontSize > 250 ?
                canvas.height / 2 + fontSize * 0.2 :
                canvas.height / 2;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Force background update after resize
            setTimeout(() => {
                if (backgroundImageUrl) {
                    updateBackgroundImageUrl();
                } else {
                    updateBackgroundColor();
                }
            }, 100);

            // Only reset animation state if we're not currently animating
            // This prevents fullscreen transitions from interrupting the animation
            if (!isAnimating || letterData.length === 0) {
                scrollOffset = 0;
                currentLine = 0;
                letterData = [];
                trailPoints = []; // Clear trail points
                isAnimating = false;
                document.getElementById('startBtn').textContent = 'Start';
            } else {
                // If we're animating, just regenerate the letter paths for the new canvas size
                if (letterData.length > 0) {
                    regenerateLetterPaths();
                }
            }
        }// Listen for URL hash changes (manual hash sharing)
        window.addEventListener('hashchange', () => {
            const hash = window.location.hash.substring(1);
            if (hash) {
                // Decrypt and set text input from hash
                document.getElementById('mainTextInput').value = decryptMessage(hash);
            }
        });

        function parseUrlParameters() {
            const urlParams = new URLSearchParams(window.location.search);

            // Parse and apply all settings
            if (urlParams.has('text')) {
                document.getElementById('mainTextInput').value = decryptMessage(urlParams.get('text'));
            }
            if (urlParams.has('from')) {
                document.getElementById('fromInput').value = decryptMessage(urlParams.get('from'));
            }
            if (urlParams.has('lpm')) {
                document.getElementById('lpmSlider').value = urlParams.get('lpm');
                updateLPM();
            }
            if (urlParams.has('scale')) {
                document.getElementById('zoomSlider').value = urlParams.get('scale');
                updateZoom();
            }
            if (urlParams.has('lineOff')) {
                document.getElementById('lineOffMode').checked = urlParams.get('lineOff') === 'true';
                updateLineOffMode();
            }
            if (urlParams.has('trail')) {
                document.getElementById('trailSlider').value = urlParams.get('trail');
                updateTrailLength();
            }
            if (urlParams.has('dotSize')) {
                document.getElementById('dotSizeSlider').value = urlParams.get('dotSize');
                updateDotSize();
            }
            if (urlParams.has('jitter')) {
                document.getElementById('jitterSlider').value = urlParams.get('jitter');
                updateJitter();
            }
            if (urlParams.has('jitterFreq')) {
                document.getElementById('jitterFreqSlider').value = urlParams.get('jitterFreq');
                updateJitterFrequency();
            } if (urlParams.has('jitterShape')) {
                document.getElementById('jitterShape').value = urlParams.get('jitterShape');
                updateJitterShape();
            }
            if (urlParams.has('pathJitter')) {
                document.getElementById('pathJitterSlider').value = urlParams.get('pathJitter');
                updatePathJitter();
            }
            if (urlParams.has('pathJitterFreq')) {
                document.getElementById('pathJitterFreqSlider').value = urlParams.get('pathJitterFreq');
                updatePathJitterFrequency();
            }
            if (urlParams.has('pathJitterShape')) {
                document.getElementById('pathJitterShape').value = urlParams.get('pathJitterShape');
                updatePathJitterShape();
            }
            if (urlParams.has('font')) {
                document.getElementById('fontSelect').value = urlParams.get('font');
                changeFont();
            }
            if (urlParams.has('colorMode')) {
                document.getElementById('colorMode').value = urlParams.get('colorMode');
                toggleColorMode();
            }
            if (urlParams.has('singleColor')) {
                document.getElementById('singleColor').value = urlParams.get('singleColor');
            }
            if (urlParams.has('glow')) {
                document.getElementById('glowSlider').value = urlParams.get('glow');
                updateGlow();
            }
            if (urlParams.has('flicker')) {
                document.getElementById('flickerSlider').value = urlParams.get('flicker');
                updateFlicker();
            }
            if (urlParams.has('lineSpacing')) {
                document.getElementById('lineSpacingSlider').value = urlParams.get('lineSpacing');
                updateLineSpacing();
            }
            if (urlParams.has('letterSpacing')) {
                document.getElementById('letterSpacingSlider').value = urlParams.get('letterSpacing');
                updateLetterSpacing();
            }
            if (urlParams.has('layoutMode')) {
                document.getElementById('layoutMode').value = urlParams.get('layoutMode');
                updateLayoutMode();
            }
            if (urlParams.has('tickerLoop')) {
                document.getElementById('tickerLoop').checked = urlParams.get('tickerLoop') === 'true';
                updateTickerLoop();
            }
            if (urlParams.has('textAlignment')) {
                document.getElementById('textAlignment').value = urlParams.get('textAlignment');
                updateTextAlignment();
            }
            if (urlParams.has('fontWeight')) {
                document.getElementById('fontWeight').value = urlParams.get('fontWeight');
                updateFontWeight();
            }
            if (urlParams.has('fontStyle')) {
                document.getElementById('fontStyle').value = urlParams.get('fontStyle');
                updateFontStyle();
            } if (urlParams.has('backgroundMode')) {
                document.getElementById('backgroundMode').value = urlParams.get('backgroundMode');
                updateBackgroundMode();
            }
            if (urlParams.has('backgroundColor')) {
                document.getElementById('backgroundColor').value = urlParams.get('backgroundColor');
            }
            if (urlParams.has('gradientAngle')) {
                document.getElementById('gradientAngle').value = urlParams.get('gradientAngle');
                updateGradientAngle();
            }
            if (urlParams.has('gradientColor1')) {
                document.getElementById('gradientColor1').value = urlParams.get('gradientColor1');
            }
            if (urlParams.has('gradientColor2')) {
                document.getElementById('gradientColor2').value = urlParams.get('gradientColor2');
            }
            if (urlParams.has('gradientColor3')) {
                document.getElementById('gradientColor3').value = urlParams.get('gradientColor3');
            }
            if (urlParams.has('gradientColor4')) {
                document.getElementById('gradientColor4').value = urlParams.get('gradientColor4');
            }
            if (urlParams.has('gradientColor5')) {
                document.getElementById('gradientColor5').value = urlParams.get('gradientColor5');
            }
            if (urlParams.has('gradientColor6')) {
                document.getElementById('gradientColor6').value = urlParams.get('gradientColor6');
            }

            // Parse gradient color enabled states
            if (urlParams.has('gradientColor1Enabled')) {
                document.getElementById('gradientColor1').setAttribute('data-enabled', urlParams.get('gradientColor1Enabled'));
            }
            if (urlParams.has('gradientColor2Enabled')) {
                document.getElementById('gradientColor2').setAttribute('data-enabled', urlParams.get('gradientColor2Enabled'));
            }
            if (urlParams.has('gradientColor3Enabled')) {
                document.getElementById('gradientColor3').setAttribute('data-enabled', urlParams.get('gradientColor3Enabled'));
            }
            if (urlParams.has('gradientColor4Enabled')) {
                document.getElementById('gradientColor4').setAttribute('data-enabled', urlParams.get('gradientColor4Enabled'));
            }
            if (urlParams.has('gradientColor5Enabled')) {
                document.getElementById('gradientColor5').setAttribute('data-enabled', urlParams.get('gradientColor5Enabled'));
            }
            if (urlParams.has('gradientColor6Enabled')) {
                document.getElementById('gradientColor6').setAttribute('data-enabled', urlParams.get('gradientColor6Enabled'));
            }

            if (urlParams.has('fillMode')) {
                document.getElementById('fillMode').value = urlParams.get('fillMode');
                updateFillMode();
            }
            if (urlParams.has('fillColor')) {
                document.getElementById('fillColor').value = urlParams.get('fillColor');
            }
            if (urlParams.has('fullscreenOnStart')) {
                document.getElementById('fullscreenOnStart').checked = urlParams.get('fullscreenOnStart') === 'true';
            }

            // Parse music settings
            if (urlParams.has('musicSelect')) {
                document.getElementById('musicSelect').value = urlParams.get('musicSelect');
                updateMusicSelection();
            }
            if (urlParams.has('musicVolume')) {
                document.getElementById('musicVolume').value = urlParams.get('musicVolume');
                updateMusicVolume();
            }
            if (urlParams.has('musicLoop')) {
                document.getElementById('musicLoop').checked = urlParams.get('musicLoop') === 'true';
                updateMusicLoop();
            }

            // Parse immediate fill setting
            if (urlParams.has('immediateFill')) {
                document.getElementById('immediateFill').checked = urlParams.get('immediateFill') === 'true';
                updateImmediateFill();
            }

            // Parse background image URL
            if (urlParams.has('backgroundImageUrl')) {
                document.getElementById('backgroundImageUrl').value = urlParams.get('backgroundImageUrl');
                updateBackgroundImageUrl();
            }

            // Update gradient color visibility first, then background color after ALL parameters are loaded
            updateGradientColorVisibility();
            updateBackgroundColor();

            // Auto-start if autoplay parameter is present
            if (urlParams.has('autoplay') && urlParams.get('autoplay') === 'true') {
                // Force fullscreen checkbox to be checked for shared links
                document.getElementById('fullscreenOnStart').checked = true;

                // Show message overlay for shared messages
                const messageOverlay = document.getElementById('messageOverlay');
                const messageButton = document.getElementById('messageButton');
                const fromValue = document.getElementById('fromInput').value;

                if (fromValue) {
                    messageButton.textContent = `You have a message from ${fromValue}. Click here to view it.`;
                } else {
                    messageButton.textContent = 'You have a shared message. Click here to view it.';
                }

                messageOverlay.classList.remove('hidden');

                messageButton.onclick = () => {
                    messageOverlay.classList.add('hidden');
                    // Auto-start the animation
                    setTimeout(() => {
                        if (!isAnimating) {
                            toggleAnimation();
                        }
                    }, 500);
                };
            }
        }

        // Function to parse all settings for sharing
        function parseAllSettings() {
            return {
                text: encryptMessage(document.getElementById('mainTextInput').value),
                from: encryptMessage(document.getElementById('fromInput').value),
                lpm: document.getElementById('lpmSlider').value,
                scale: document.getElementById('zoomSlider').value,
                lineOff: document.getElementById('lineOffMode').checked,
                trail: document.getElementById('trailSlider').value,
                dotSize: document.getElementById('dotSizeSlider').value,
                jitter: document.getElementById('jitterSlider').value,
                jitterFreq: document.getElementById('jitterFreqSlider').value,
                jitterShape: document.getElementById('jitterShape').value,
                pathJitter: document.getElementById('pathJitterSlider').value,
                pathJitterFreq: document.getElementById('pathJitterFreqSlider').value,
                pathJitterShape: document.getElementById('pathJitterShape').value,
                font: document.getElementById('fontSelect').value,
                fontWeight: document.getElementById('fontWeight').value,
                fontStyle: document.getElementById('fontStyle').value,
                colorMode: document.getElementById('colorMode').value,
                singleColor: document.getElementById('singleColor').value,
                glow: document.getElementById('glowSlider').value,
                flicker: document.getElementById('flickerSlider').value,
                lineSpacing: document.getElementById('lineSpacingSlider').value,
                letterSpacing: document.getElementById('letterSpacingSlider').value,
                layoutMode: document.getElementById('layoutMode').value,
                tickerLoop: document.getElementById('tickerLoop').checked,
                textAlignment: document.getElementById('textAlignment').value,
                backgroundMode: document.getElementById('backgroundMode').value,
                backgroundColor: document.getElementById('backgroundColor').value,
                gradientAngle: document.getElementById('gradientAngle').value,
                gradientColor1: document.getElementById('gradientColor1').value,
                gradientColor2: document.getElementById('gradientColor2').value,
                gradientColor3: document.getElementById('gradientColor3').value,
                gradientColor4: document.getElementById('gradientColor4').value,
                gradientColor5: document.getElementById('gradientColor5').value,
                gradientColor6: document.getElementById('gradientColor6').value,
                // Add gradient color enabled states
                gradientColor1Enabled: document.getElementById('gradientColor1').getAttribute('data-enabled') || 'true',
                gradientColor2Enabled: document.getElementById('gradientColor2').getAttribute('data-enabled') || 'true',
                gradientColor3Enabled: document.getElementById('gradientColor3').getAttribute('data-enabled') || 'false',
                gradientColor4Enabled: document.getElementById('gradientColor4').getAttribute('data-enabled') || 'false',
                gradientColor5Enabled: document.getElementById('gradientColor5').getAttribute('data-enabled') || 'false',
                gradientColor6Enabled: document.getElementById('gradientColor6').getAttribute('data-enabled') || 'false',
                fillMode: document.getElementById('fillMode').value,
                fillColor: document.getElementById('fillColor').value,
                fullscreenOnStart: 'true', // Always force fullscreen for shared links
                // Add music settings
                musicSelect: document.getElementById('musicSelect').value,
                musicVolume: document.getElementById('musicVolume').value,
                musicLoop: document.getElementById('musicLoop').checked,
                // Add immediate fill setting
                immediateFill: document.getElementById('immediateFill').checked,
                // Add background image URL
                backgroundImageUrl: document.getElementById('backgroundImageUrl').value,
                autoplay: 'true'
            };
        }

        function updateZoom() {
            const value = document.getElementById('zoomSlider').value;
            zoomFactor = parseFloat(value);
            fontSize = baseFontSize * zoomFactor;
            document.getElementById('zoomValue').textContent = Math.round(fontSize) + 'px';

            // If we have text loaded, regenerate the paths with new zoom
            if (letterData.length > 0) {
                regenerateLetterPaths();
                redrawCurrentState();
            }
        }

        function updateGlow() {
            const value = document.getElementById('glowSlider').value;
            glowIntensity = parseInt(value);
            document.getElementById('glowValue').textContent = value + '%';

            // Immediate visual update
            if (letterData.length > 0 && !isAnimating) {
                redrawCurrentState();
            }
        }

        function updateFlicker() {
            const value = document.getElementById('flickerSlider').value;
            flickerProbability = parseInt(value);
            document.getElementById('flickerValue').textContent = value + '%';

            // Start or stop flicker animation based on the setting
            if (flickerProbability > 0 && letterData.length > 0 && !isAnimating) {
                startFlickerAnimation();
            } else {
                stopFlickerAnimation();
            }
        }

        function setupAdvancedSliderInteraction() {
            // This function can be used to add advanced interactions to sliders
            // For now, it's just a placeholder
            console.log('Advanced slider interaction setup complete');
        }

        // Function to extract text from URL
        async function extractTextFromUrl(url) {
            try {
                // Use a CORS proxy or direct fetch depending on the URL
                const response = await fetch(url);
                const html = await response.text();

                // Create a temporary DOM element to parse HTML
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = html;

                // Remove script and style elements
                const scripts = tempDiv.querySelectorAll('script, style');
                scripts.forEach(el => el.remove());

                // Extract text content
                let text = tempDiv.textContent || tempDiv.innerText || '';

                // Clean up the text
                text = text.replace(/\s+/g, ' ').trim();

                return text;
            } catch (error) {
                console.error('Error extracting text from URL:', error);
                throw error;
            }
        }

        function regenerateLetterPaths() {
            if (!letterData || letterData.length === 0) return;

            const text = letterData.map(letter => letter.char).join('');
            let x = margin;
            let y = baselineY;
            let currentLineNum = 0;

            // Use current line spacing setting to calculate line height
            const currentLineSpacing = parseInt(document.getElementById('lineSpacingSlider').value);
            const spacingValues = [100, 150, 200, 250, 300, 350, 400, 500, 600, 800, 1000];
            const baseSpacing = spacingValues[currentLineSpacing];
            lineHeight = fontSize * (baseSpacing / 300); if (layoutMode === 'ticker') {
                // Ticker mode: position text starting from right edge, scrolling left
                // Center vertically, accounting for font size for better visual centering
                y = canvas.height / 2 + fontSize * 0.3; // Adjust baseline for visual centering

                // Find the currently drawing letter
                let currentDrawingIndex = -1;
                for (let i = 0; i < letterData.length; i++) {
                    if (letterData[i].revealed && !letterData[i].drawingComplete) {
                        currentDrawingIndex = i;
                        break;
                    }
                }

                // If no letter is currently drawing, find the next unrevealed letter
                if (currentDrawingIndex === -1) {
                    for (let i = 0; i < letterData.length; i++) {
                        if (!letterData[i].revealed) {
                            currentDrawingIndex = i;
                            break;
                        }
                    }
                }

                // Fallback to last letter if all are complete
                if (currentDrawingIndex === -1 && letterData.length > 0) {
                    currentDrawingIndex = letterData.length - 1;
                }

                // Default to first letter
                if (currentDrawingIndex === -1) {
                    currentDrawingIndex = 0;
                }

                // Calculate total text width
                let totalTextWidth = 0;
                for (let i = 0; i < letterData.length; i++) {
                    const ch = letterData[i].char;
                    const glyph = font.charToGlyph(ch) || font.charToGlyph(' ');
                    const w = glyph.advanceWidth * (fontSize / font.unitsPerEm) * letterSpacing;
                    totalTextWidth += w;
                }

                // Position text to start from right edge with margin
                const rightMargin = 100; // Increased margin
                x = canvas.width - rightMargin;

                for (let i = 0; i < letterData.length; i++) {
                    const ch = letterData[i].char;
                    const glyph = font.charToGlyph(ch) || font.charToGlyph(' ');
                    const w = glyph.advanceWidth * (fontSize / font.unitsPerEm) * letterSpacing;

                    const path = glyph.getPath(x, y, fontSize);
                    let pts = samplePathWithCornerDetection(path.commands);

                    // Apply italic transform if needed
                    pts = applyItalicTransform(pts);

                    // Keep existing color, revealed state, and drawing progress but update paths and position
                    letterData[i].pts = pts;
                    letterData[i].x = x;
                    letterData[i].y = y;
                    letterData[i].line = 0; // All on same line for ticker
                    // Preserve currentPointIndex and drawingComplete

                    x += w;
                }
            } else {
                // Wrap mode with alignment - use same logic as startReveal
                const lines = [];
                let currentLineChars = [];
                let currentLineWidth = 0;
                let lineIndex = 0;

                // First pass: calculate line widths (same as startReveal)
                let tempX = margin;
                for (let i = 0; i < letterData.length; i++) {
                    const ch = letterData[i].char;
                    const glyph = font.charToGlyph(ch) || font.charToGlyph(' ');
                    const w = glyph.advanceWidth * (fontSize / font.unitsPerEm) * letterSpacing;

                    // Check if we need to wrap
                    if (ch === ' ') {
                        // Look ahead to see if next word fits
                        let nextWordEnd = i + 1;
                        while (nextWordEnd < letterData.length && letterData[nextWordEnd].char !== ' ') {
                            nextWordEnd++;
                        }

                        let nextWordWidth = 0;
                        for (let j = i + 1; j < nextWordEnd; j++) {
                            const nextGlyph = font.charToGlyph(letterData[j].char) || font.charToGlyph(' ');
                            nextWordWidth += nextGlyph.advanceWidth * (fontSize / font.unitsPerEm) * letterSpacing;
                        }

                        if (tempX + nextWordWidth > canvas.width - margin) {
                            // End current line
                            lines.push({
                                chars: currentLineChars,
                                width: currentLineWidth,
                                lineIndex: lineIndex
                            });

                            // Start new line
                            currentLineChars = [];
                            currentLineWidth = 0;
                            tempX = margin;
                            lineIndex++;
                        }
                    }

                    currentLineChars.push({
                        char: ch,
                        width: w,
                        charIndex: i
                    });
                    currentLineWidth += w;
                    tempX += w;
                }

                // Add the last line
                if (currentLineChars.length > 0) {
                    lines.push({
                        chars: currentLineChars,
                        width: currentLineWidth,
                        lineIndex: lineIndex
                    });
                }

                // Calculate starting X position for each line based on alignment
                lines.forEach(line => {
                    switch (textAlignment) {
                        case 'center':
                            const availableWidth = canvas.width - 2 * margin;
                            line.startX = margin + Math.max(0, (availableWidth - line.width) / 2);
                            break;
                        case 'right':
                            line.startX = Math.max(margin, canvas.width - line.width - margin);
                            break;
                        case 'justify':
                            line.startX = margin;
                            // Calculate extra spacing for justify (except last line)
                            if (line.lineIndex < lines.length - 1) {
                                const spaceCount = line.chars.filter(c => c.char === ' ').length;
                                if (spaceCount > 0) {
                                    const availableWidth = canvas.width - 2 * margin;
                                    const extraSpace = Math.max(0, availableWidth - line.width);
                                    line.extraSpacePerSpace = extraSpace / spaceCount;
                                } else {
                                    line.extraSpacePerSpace = 0;
                                }
                            } else {
                                line.extraSpacePerSpace = 0; // Don't justify last line
                            }
                            break;
                        default: // left
                            line.startX = margin;
                            break;
                    }
                });

                // Now update letter positions
                let currentLineData = lines[0];
                let charIndexInLine = 0;
                let extraSpaceAccumulated = 0;

                for (let i = 0; i < letterData.length; i++) {
                    const ch = letterData[i].char;

                    // Check if we've moved to a new line
                    if (currentLineData && charIndexInLine >= currentLineData.chars.length) {
                        const nextLineIndex = currentLineData.lineIndex + 1;
                        if (nextLineIndex < lines.length) {
                            currentLineData = lines[nextLineIndex];
                            charIndexInLine = 0;
                            extraSpaceAccumulated = 0;
                        }
                    }

                    const glyph = font.charToGlyph(ch) || font.charToGlyph(' ');
                    const w = glyph.advanceWidth * (fontSize / font.unitsPerEm) * letterSpacing;

                    // Add extra space for justify alignment
                    if (textAlignment === 'justify' && currentLineData && currentLineData.extraSpacePerSpace && ch === ' ') {
                        extraSpaceAccumulated += currentLineData.extraSpacePerSpace;
                    }

                    // Calculate position
                    let newX, newY;
                    if (currentLineData && charIndexInLine === 0) {
                        newX = currentLineData.startX;
                    } else if (currentLineData) {
                        newX = currentLineData.startX + currentLineData.chars.slice(0, charIndexInLine).reduce((sum, c) => sum + c.width, 0) + extraSpaceAccumulated;
                    } else {
                        newX = margin;
                    }

                    // Improved baseline calculation for better centering
                    const adjustedBaselineY = fontSize > 250 ?
                        canvas.height / 2 + fontSize * 0.3 :
                        baselineY + fontSize * 0.1;
                    newY = adjustedBaselineY + (currentLineData ? currentLineData.lineIndex : 0) * lineHeight;

                    const path = glyph.getPath(newX, newY, fontSize);
                    let pts = samplePathWithCornerDetection(path.commands);

                    // Apply italic transform if needed
                    pts = applyItalicTransform(pts);

                    // Update letter data while preserving drawing progress
                    letterData[i].pts = pts;
                    letterData[i].x = newX;
                    letterData[i].y = newY;
                    letterData[i].line = currentLineData ? currentLineData.lineIndex : 0;
                    // Preserve currentPointIndex and drawingComplete

                    charIndexInLine++;
                }
            }

            // Redraw the canvas with new layout
            redrawCurrentState();
        } function redrawCurrentState() {
            if (letterData.length === 0) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Calculate scroll offset
            let xScrollOffset = 0;
            let yScrollOffset = 0;
            const scrollCurrentTime = performance.now();
            const deltaTime = lastScrollTime > 0 ? scrollCurrentTime - lastScrollTime : 0;
            lastScrollTime = scrollCurrentTime;

            // Draw trail points first (behind the main drawing)
            if (trailLength > 0 && trailPoints.length > 0) {
                const currentTime = performance.now();

                // Remove expired trail points
                trailPoints = trailPoints.filter(point => (currentTime - point.timestamp) <= (trailLength * 1000));

                // Draw trail with fading effect
                for (let i = 0; i < trailPoints.length; i++) {
                    const point = trailPoints[i];
                    const age = currentTime - point.timestamp;
                    const maxAge = trailLength * 1000;
                    const alpha = 1 - (age / maxAge); // Fade from 1 to 0

                    if (alpha > 0) {
                        ctx.save();
                        ctx.globalAlpha = alpha * 0.6; // Trail is semi-transparent
                        ctx.fillStyle = point.color;
                        ctx.shadowColor = point.color;
                        ctx.shadowBlur = glowIntensity * alpha;
                        ctx.beginPath();
                        ctx.arc(point.x, point.y, dotSize * alpha * 0.8, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.restore();
                    }
                }
            } if (layoutMode === 'wrap') {
                // Smooth auto-scroll to keep current drawing in view (vertical scrolling)
                // Better centering for large text
                const visibleLines = Math.floor(canvas.height / lineHeight);
                const targetCenterLine = Math.floor(visibleLines / 2);

                if (letterData.length > 0) {
                    const lastRevealedLetter = letterData.find(l => l.revealed && !l.drawingComplete);
                    if (lastRevealedLetter) {
                        // Calculate target scroll to keep current line centered
                        const currentLineNum = lastRevealedLetter.line;
                        const targetScrollY = Math.max(0, (currentLineNum - targetCenterLine) * lineHeight);

                        // Smooth scroll towards target using delta time
                        const scrollSpeed = 400; // pixels per second (increased for more responsive)
                        const maxScrollStep = deltaTime > 0 ? (scrollSpeed * deltaTime) / 1000 : 0;
                        const diff = targetScrollY - wrapScrollOffset;

                        if (Math.abs(diff) > maxScrollStep) {
                            wrapScrollOffset += Math.sign(diff) * maxScrollStep;
                        } else {
                            wrapScrollOffset = targetScrollY;
                        }
                    }
                }
                yScrollOffset = wrapScrollOffset;
            } else if (layoutMode === 'ticker') {
                // Smooth ticker scrolling - keep pen at fixed position, scroll text left continuously
                let currentDrawingIndex = -1;

                //
                for (let i = 0; i < letterData.length; i++) {
                    if (letterData[i].revealed && !letterData[i].drawingComplete) {
                        currentDrawingIndex = i;
                        break;
                    }
                }

                // If no letter is currently drawing, find the next letter to reveal
                if (currentDrawingIndex === -1) {
                    for (let i = 0; i < letterData.length; i++) {
                        if (!letterData[i].revealed) {
                            currentDrawingIndex = i;
                            break;
                        }
                    }
                }

                // Fallback to last letter
                if (currentDrawingIndex === -1 && letterData.length > 0) {
                    currentDrawingIndex = letterData.length - 1;
                }

                if (currentDrawingIndex >= 0) {
                    const currentLetter = letterData[currentDrawingIndex];

                    // Keep pen at 70% from left edge
                    const targetPenX = canvas.width * 0.7;

                    // Calculate smooth scroll offset based on drawing progress
                    let letterProgress = 0;
                    if (currentLetter.pts && currentLetter.pts.length > 0) {
                        letterProgress = currentLetter.currentPointIndex / currentLetter.pts.length;
                    }

                    // Calculate the width of the current letter for smooth advancement
                    const currentLetterWidth = currentDrawingIndex + 1 < letterData.length ?
                        letterData[currentDrawingIndex + 1].x - currentLetter.x :
                        font.charToGlyph(currentLetter.char).advanceWidth * (fontSize / font.unitsPerEm) * letterSpacing;

                    // Smooth scrolling: interpolate between current and next letter position
                    const baseX = currentLetter.x;
                    const progressOffset = letterProgress * currentLetterWidth * 0.8; // 80% of letter width for smooth transition

                    // Calculate scroll offset to keep writing position at target
                    xScrollOffset = (baseX + progressOffset) - targetPenX;
                } else {
                    xScrollOffset = 0;
                }
            }

            // Apply jitter if enabled
            const currentTime = globalAnimationStartTime ? performance.now() - globalAnimationStartTime : 0;

            // Draw all letters (all visible before animation starts, then only revealed during animation)
            for (let i = 0; i < letterData.length; i++) {
                const letter = letterData[i];

                // Show all letters before animation starts, or only revealed letters during animation
                const shouldShow = !isAnimating || letter.revealed;
                if (!shouldShow) continue;                // Apply regular jitter to entire letter if jitter is enabled
                let pathToUse = letter.pts;
                let letterJitterOffset = { x: 0, y: 0 };
                if (jitterAmount > 0 && pathToUse && pathToUse.length > 0) {
                    // Calculate individual jitter offset for each letter
                    // Use letter index and character code for unique variation per letter
                    const letterPhaseOffset = i * 3.7 + letter.char.charCodeAt(0) * 0.1;
                    const timeOffset = currentTime * 0.001 + letterPhaseOffset; // Convert to seconds
                    letterJitterOffset = calculateJitter(timeOffset * 1000, jitterFrequency, jitterShape);

                    // Apply the jitter offset to all points in the letter
                    pathToUse = pathToUse.map(point => ({
                        ...point,
                        x: point.x + letterJitterOffset.x * jitterAmount,
                        y: point.y + letterJitterOffset.y * jitterAmount
                    }));
                }
                // Apply path jitter if enabled and stored
                if (pathJitterAmount > 0 && letter.pathJitterOffsets && letter.pathJitterOffsets.length === pathToUse.length) {
                    // Use pre-calculated path jitter offsets
                    pathToUse = pathToUse.map((point, j) => ({
                        ...point,
                        x: point.x + letter.pathJitterOffsets[j].x,
                        y: point.y + letter.pathJitterOffsets[j].y
                    }));
                }

                if (pathToUse && pathToUse.length > 0) {
                    // Apply flicker effect - randomly skip drawing some letters
                    const shouldFlicker = flickerProbability > 0 && Math.random() * 100 < flickerProbability;
                    if (!shouldFlicker) {
                        ctx.strokeStyle = letter.color;
                        ctx.shadowColor = letter.color;

                        // Enhanced glow with multiple layers for better contour following
                        const baseGlow = Math.max(2, glowIntensity);

                        // Create multiple glow layers for better contour following
                        for (let glowLayer = 3; glowLayer >= 1; glowLayer--) {
                            ctx.save();
                            ctx.shadowBlur = baseGlow * glowLayer * 2;
                            ctx.shadowColor = letter.color;
                            ctx.globalAlpha = 0.3 / glowLayer; // Fade outer layers

                            // Use dynamic line thickness based on font weight
                            ctx.lineWidth = getLineThickness() + (glowLayer - 1);
                            ctx.lineCap = 'round';
                            ctx.lineJoin = 'round';

                            // Draw the path progressively for this glow layer
                            if (!lineOffMode && pathToUse.length > 0) {
                                ctx.beginPath();

                                // Determine how many points to draw
                                const pointsToDraw = letter.drawingComplete ?
                                    pathToUse.length :
                                    Math.min(letter.currentPointIndex, pathToUse.length);

                                if (pointsToDraw > 0) {
                                    // Apply appropriate scroll offset based on mode
                                    const drawX = pathToUse[0].x - xScrollOffset;
                                    const drawY = pathToUse[0].y - yScrollOffset;
                                    ctx.moveTo(drawX, drawY);

                                    for (let j = 1; j < pointsToDraw; j++) {
                                        const point = pathToUse[j];
                                        const pointX = point.x - xScrollOffset;
                                        const pointY = point.y - yScrollOffset;

                                        if (point.isPenLift) {
                                            ctx.moveTo(pointX, pointY);
                                        } else {
                                            ctx.lineTo(pointX, pointY);
                                        }
                                    }
                                    ctx.stroke();
                                }
                            }
                            ctx.restore();
                        }

                        // Draw fill if fill mode is enabled (progressive liquid fill)
                        if (fillMode !== 'none' && pathToUse && pathToUse.length > 0) {
                            let fillColorToUse = letter.color; // Default to outline color

                            if (fillMode === 'custom') {
                                fillColorToUse = fillColor;
                            } else if (fillMode === 'neon') {
                                fillColorToUse = neonColors[i % neonColors.length];
                            } else if (fillMode === 'pastel') {
                                // Use a different offset for pastel fills to get different colors
                                fillColorToUse = pastelColors[(i + 7) % pastelColors.length];
                            } else if (fillMode === 'cycling') {
                                const colorIndex = (i + Math.floor(currentTime / 200)) % (neonColors.length + pastelColors.length);
                                fillColorToUse = colorIndex < neonColors.length ?
                                    neonColors[colorIndex] :
                                    pastelColors[colorIndex - neonColors.length];
                            }

                            // Create liquid pouring fill effect
                            ctx.save();

                            // Only fill letters that are 100% drawn
                            if (letter.drawingComplete) {
                                // Initialize fill start time if not set
                                if (!letter.fillStartTime) {
                                    letter.fillStartTime = performance.now();
                                }

                                // Calculate fill progress (water rising from bottom)
                                const fillDuration = 2000; // 2 seconds to fill completely
                                const fillElapsed = performance.now() - letter.fillStartTime;
                                const fillProgress = Math.min(1, fillElapsed / fillDuration);

                                if (fillProgress > 0) {
                                    // Get letter bounds for water fill effect
                                    const letterBounds = getLetterBounds(pathToUse, xScrollOffset, yScrollOffset);
                                    if (letterBounds) {
                                        // Create clipping rectangle for water level (from bottom up)
                                        const fillHeight = letterBounds.height * fillProgress;
                                        const fillTop = letterBounds.bottom - fillHeight;

                                        ctx.save();
                                        ctx.beginPath();
                                        ctx.rect(
                                            letterBounds.left - 10,
                                            fillTop,
                                            letterBounds.width + 20,
                                            fillHeight + 10
                                        );
                                        ctx.clip();

                                        // Create path from the actual letter shape (including jitter/italic)
                                        ctx.beginPath();
                                        if (pathToUse.length > 0) {
                                            const startPoint = pathToUse[0];
                                            ctx.moveTo(startPoint.x - xScrollOffset, startPoint.y - yScrollOffset);

                                            for (let j = 1; j < pathToUse.length; j++) {
                                                const point = pathToUse[j];
                                                const pointX = point.x - xScrollOffset;
                                                const pointY = point.y - yScrollOffset;

                                                if (point.isPenLift) {
                                                    ctx.moveTo(pointX, pointY);
                                                } else {
                                                    ctx.lineTo(pointX, pointY);
                                                }
                                            }
                                        }
                                        ctx.closePath();

                                        // Fill the clipped area with water effect
                                        ctx.fillStyle = fillColorToUse;
                                        ctx.globalAlpha = 0.6; // Semi-transparent for water effect
                                        ctx.fill();
                                        ctx.restore();
                                    }
                                }
                            }

                            ctx.restore();
                        }
                        // Draw the pen dot at current position if letter is being drawn
                        if (!letter.drawingComplete && letter.currentPointIndex > 0 && letter.currentPointIndex < pathToUse.length) {
                            const currentPoint = pathToUse[letter.currentPointIndex - 1];
                            if (currentPoint) {
                                // Apply scroll offset
                                const penX = currentPoint.x - xScrollOffset;
                                const penY = currentPoint.y - yScrollOffset;

                                // Add to trail if trail is enabled - store screen coordinates (already offset)
                                if (trailLength > 0) {
                                    trailPoints.push({
                                        x: penX,
                                        y: penY,
                                        color: letter.color,
                                        timestamp: performance.now()
                                    });

                                    // Limit trail points for performance (keep last 500 points max)
                                    if (trailPoints.length > 500) {
                                        trailPoints = trailPoints.slice(-500);
                                    }
                                }

                                ctx.shadowBlur = glowIntensity * 2; // Extra glow for pen dot
                                ctx.fillStyle = letter.color;
                                ctx.beginPath();
                                ctx.arc(penX, penY, dotSize, 0, 2 * Math.PI);
                                ctx.fill();
                            }
                        }

                        ctx.shadowBlur = 0; // Reset shadow
                    }
                }
            }
        }        // Ticker animation loop for continuous movement
        let tickerAnimationId = null;
        let tickerLastTime = 0;
        function tickerAnimationLoop(currentTime) {
            if (layoutMode === 'ticker' && letterData.length > 0) {
                // Calculate smooth scroll speed - ticker should always be in motion
                const deltaTime = currentTime - tickerLastTime;
                if (tickerLastTime > 0) {
                    const scrollSpeed = 80; // pixels per second (increased for smoother motion)
                    tickerScrollOffset += (scrollSpeed * deltaTime) / 1000;
                }
                tickerLastTime = currentTime;

                // Loop logic: if text has fully scrolled off left and loop is enabled, restart
                if (tickerLoop) {
                    const totalTextWidth = getTotalTickerTextWidth();
                    if (tickerScrollOffset > totalTextWidth + canvas.width) {
                        tickerScrollOffset = 0;
                    }
                }

                redrawCurrentState();
                tickerAnimationId = requestAnimationFrame(tickerAnimationLoop);
            } else if (layoutMode !== 'ticker' && hasActiveFillAnimations()) {
                // Continue drawing if there are active fill animations
                redrawCurrentState();
                tickerAnimationId = requestAnimationFrame(tickerAnimationLoop);
            } else {
                tickerAnimationId = null;
                tickerLastTime = 0;
            }
        }

        // Helper function to calculate total ticker text width
        function getTotalTickerTextWidth() {
            if (!letterData || letterData.length === 0) return 0;
            let totalWidth = 0;
            for (let i = 0; i < letterData.length; i++) {
                if (letterData[i].width) {
                    totalWidth += letterData[i].width;
                }
                // Add letter spacing between characters
                if (i < letterData.length - 1) {
                    totalWidth += (fontSize * letterSpacing * 0.2);
                }
            }
            return totalWidth;
        }
        // Start ticker animation when layout mode changes to ticker
        function startTickerIfNeeded() {
            if (layoutMode === 'ticker' && letterData.length > 0 && !tickerAnimationId) {
                tickerLastTime = 0; // Reset timing
                tickerAnimationId = requestAnimationFrame(tickerAnimationLoop);
            }
        }

        // Stop ticker animation
        function stopTickerAnimation() {
            if (tickerAnimationId) {
                cancelAnimationFrame(tickerAnimationId);
                tickerAnimationId = null;
            }
        }

        // Fill animation loop for non-ticker modes
        function startFillAnimationLoop() {
            if (tickerAnimationId) return; // Already running (reuse ticker animation)

            function fillAnimationLoop(currentTime) {
                if (hasActiveFillAnimations()) {
                    redrawCurrentState();
                    tickerAnimationId = requestAnimationFrame(fillAnimationLoop);
                } else {
                    tickerAnimationId = null;
                }
            }

            tickerAnimationId = requestAnimationFrame(fillAnimationLoop);
        }

        function samplePathWithCornerDetection(commands) {
            const points = [];
            let currentX = 0, currentY = 0;

            commands.forEach(cmd => {
                switch (cmd.type) {
                    case 'M':
                        // Move command - lift pen
                        currentX = cmd.x;
                        currentY = cmd.y;
                        points.push({ x: currentX, y: currentY, isPenLift: true });
                        break; case 'L':
                        // For straight lines, add intermediate points to ensure adequate sampling
                        const dx = cmd.x - currentX;
                        const dy = cmd.y - currentY;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        // Add intermediate points every 4 pixels for smoother jitter sampling
                        const stepSize = 4; // Reduced from 8 to 4 for smoother curves
                        const steps = Math.max(1, Math.floor(distance / stepSize));

                        for (let i = 1; i <= steps; i++) {
                            const t = i / steps;
                            const x = currentX + dx * t;
                            const y = currentY + dy * t;
                            points.push({ x, y });
                        }

                        currentX = cmd.x;
                        currentY = cmd.y;
                        break;
                    case 'Q':
                        // Sample quadratic curve with finer spacing for smoother jitter
                        const qDistance = Math.sqrt((cmd.x - currentX) ** 2 + (cmd.y - currentY) ** 2);
                        const qSteps = Math.max(15, Math.floor(qDistance / 4)); // Increased minimum points, smaller step size

                        for (let i = 1; i <= qSteps; i++) {
                            const t = i / qSteps;
                            const x = (1 - t) * (1 - t) * currentX + 2 * (1 - t) * t * cmd.x1 + t * t * cmd.x;
                            const y = (1 - t) * (1 - t) * currentY + 2 * (1 - t) * t * cmd.y1 + t * t * cmd.y;
                            points.push({ x, y });
                        }
                        currentX = cmd.x;
                        currentY = cmd.y;
                        break;
                    case 'C':
                        // Sample cubic curve with finer spacing for smoother jitter
                        const cDistance = Math.sqrt((cmd.x - currentX) ** 2 + (cmd.y - currentY) ** 2);
                        const cSteps = Math.max(15, Math.floor(cDistance / 4)); // Increased minimum points, smaller step size

                        for (let i = 1; i <= cSteps; i++) {
                            const t = i / cSteps;
                            const x = (1 - t) * (1 - t) * (1 - t) * currentX + 3 * (1 - t) * (1 - t) * t * cmd.x1 + 3 * (1 - t) * t * t * cmd.x2 + t * t * t * cmd.x;
                            const y = (1 - t) * (1 - t) * (1 - t) * currentY + 3 * (1 - t) * (1 - t) * t * cmd.y1 + 3 * (1 - t) * t * t * cmd.y2 + t * t * t * cmd.y;
                            points.push({ x, y });
                        }
                        currentX = cmd.x;
                        currentY = cmd.y;
                        break;
                    case 'Z':
                        // Close path - line back to start
                        if (points.length > 0) {
                            points.push({ x: points[0].x, y: points[0].y, isPenLift: true });
                        }
                        break;
                }
            });

            return points;
        }

        // Function to calculate jitter offset
        function calculateJitter(time, frequency, shape) {
            const t = (time / 1000) * frequency;
            let jitterX = 0, jitterY = 0;

            switch (shape) {
                case 'sine':
                    jitterX = Math.sin(t);
                    jitterY = Math.cos(t * 0.7);
                    break;
                case 'cosine':
                    jitterX = Math.cos(t);
                    jitterY = Math.sin(t * 0.7);
                    break;
                case 'triangle':
                    jitterX = 2 * Math.abs((t % 2) - 1) - 1;
                    jitterY = 2 * Math.abs(((t * 0.7) % 2) - 1) - 1;
                    break;
                case 'square':
                    jitterX = Math.sign(Math.sin(t));
                    jitterY = Math.sign(Math.cos(t * 0.7));
                    break;
                case 'noise':
                    // Simple pseudo-random noise
                    const seed = Math.floor(t * 10);
                    jitterX = ((seed * 9301 + 49297) % 233280) / 233280 * 2 - 1;
                    jitterY = (((seed + 1) * 9301 + 49297) % 233280) / 233280 * 2 - 1;
                    break;
                case 'abs-sine':
                    jitterX = Math.abs(Math.sin(t));
                    jitterY = Math.abs(Math.cos(t * 0.7));
                    break;
                case 'sawtooth':
                    jitterX = 2 * (t % 1) - 1;
                    jitterY = 2 * ((t * 0.7) % 1) - 1;
                    break;
                default:
                    jitterX = Math.sin(t);
                    jitterY = Math.cos(t * 0.7);
            }

            return { x: jitterX, y: jitterY };
        }        // Function to calculate path-based jitter offset
        function calculatePathJitter(distanceAlongPath, pointIndex = 0, totalPathLength = 100, letterIndex = 0, speedMultiplier = 1.0, pathDirection = null) {
            if (pathJitterAmount === 0) return { x: 0, y: 0 };

            // Get current MPL directly from pathJitterFrequency
            const currentMPL = pathJitterFrequency;

            // Use distance along path for consistent jitter regardless of drawing speed
            // MPL = modulations per letter, so we scale by the distance through this letter
            const distancePhase = (distanceAlongPath / totalPathLength) * currentMPL * (Math.PI * 2);

            // Add letter-specific offset for variation between letters
            const letterOffset = letterIndex * 0.1;
            const phase = distancePhase + letterOffset;

            let offsetX = 0;
            let offsetY = 0;

            switch (pathJitterShape) {
                case 'sine':
                    // For smooth bubble writing, apply sine wave perpendicular to path direction
                    if (pathDirection) {
                        // Calculate perpendicular direction (rotate 90 degrees)
                        const perpX = -pathDirection.y;
                        const perpY = pathDirection.x;

                        // Apply sine wave in perpendicular direction for smooth bubbles
                        const sineValue = Math.sin(phase);
                        offsetX = perpX * sineValue * pathJitterAmount;
                        offsetY = perpY * sineValue * pathJitterAmount;
                    } else {
                        // Fallback for points without clear direction (use reduced jitter)
                        offsetX = Math.sin(phase) * pathJitterAmount * 0.2;
                        offsetY = Math.cos(phase * 1.1) * pathJitterAmount * 0.2; // Slightly different frequency to avoid straight lines
                    }
                    break;

                case 'cosine':
                    // Similar to sine but with cosine wave
                    if (pathDirection) {
                        const perpX = -pathDirection.y;
                        const perpY = pathDirection.x;
                        const cosineValue = Math.cos(phase);
                        offsetX = perpX * cosineValue * pathJitterAmount;
                        offsetY = perpY * cosineValue * pathJitterAmount;
                    } else {
                        offsetX = Math.cos(phase) * pathJitterAmount * 0.2;
                        offsetY = Math.sin(phase * 1.1) * pathJitterAmount * 0.2;
                    }
                    break;

                case 'abs-sine':
                    // Absolute sine - always positive displacement
                    offsetX = Math.abs(Math.sin(phase)) * pathJitterAmount * 0.3;
                    offsetY = Math.abs(Math.cos(phase * 0.7)) * pathJitterAmount * 0.2;
                    // Center the absolute values around zero
                    offsetX -= pathJitterAmount * 0.15;
                    offsetY -= pathJitterAmount * 0.1;
                    break;

                case 'sawtooth':
                    // Sawtooth wave - linear ramp up, sharp drop
                    const sawPhase = (phase % (2 * Math.PI)) / (2 * Math.PI);
                    offsetX = (sawPhase - 0.5) * pathJitterAmount * 0.6;

                    const sawPhaseY = ((phase * 0.7) % (2 * Math.PI)) / (2 * Math.PI);
                    offsetY = (sawPhaseY - 0.5) * pathJitterAmount * 0.4;
                    break;

                case 'triangle':
                    // Triangle wave
                    const triPhaseX = phase % (2 * Math.PI);
                    const triPhaseY = (phase * 0.7) % (2 * Math.PI);

                    // Convert to triangle wave (0 to 1 to 0 to -1 to 0)
                    const triX = triPhaseX / Math.PI;
                    const triY = triPhaseY / Math.PI;

                    if (pathDirection) {
                        // Use path perpendicular direction for triangle jitter
                        const perpX = -pathDirection.y;
                        const perpY = pathDirection.x;
                        const jitterMagnitude = ((triX <= 1 ? triX : 2 - triX) - 0.5) * pathJitterAmount * 0.6;
                        offsetX = perpX * jitterMagnitude;
                        offsetY = perpY * jitterMagnitude;
                    } else {
                        // Fallback to original implementation
                        offsetX = (triX <= 1 ? triX : 2 - triX) * pathJitterAmount * 0.3 - pathJitterAmount * 0.15;
                        offsetY = (triY <= 1 ? triY : 2 - triY) * pathJitterAmount * 0.2 - pathJitterAmount * 0.1;
                    }
                    break;

                case 'square':
                    if (pathDirection) {
                        // Use path perpendicular direction for square jitter
                        const perpX = -pathDirection.y;
                        const perpY = pathDirection.x;
                        const jitterMagnitude = Math.sign(Math.sin(phase)) * pathJitterAmount * 0.3;
                        offsetX = perpX * jitterMagnitude;
                        offsetY = perpY * jitterMagnitude;
                    } else {
                        // Fallback to original implementation
                        offsetX = Math.sign(Math.sin(phase)) * pathJitterAmount * 0.3;
                        offsetY = Math.sign(Math.cos(phase * 0.7)) * pathJitterAmount * 0.2;
                    }
                    break;

                case 'noise':
                    // Controlled noise based on phase
                    const noiseX = Math.sin(phase * 12.9898) * 43758.5453;
                    const noiseY = Math.sin(phase * 0.7 * 78.233) * 43758.5453;

                    if (pathDirection) {
                        // Use path perpendicular direction for noise jitter
                        const perpX = -pathDirection.y;
                        const perpY = pathDirection.x;
                        const jitterMagnitude = (noiseX - Math.floor(noiseX) - 0.5) * pathJitterAmount * 0.6;
                        offsetX = perpX * jitterMagnitude;
                        offsetY = perpY * jitterMagnitude;
                    } else {
                        // Fallback to original implementation
                        offsetX = (noiseX - Math.floor(noiseX) - 0.5) * pathJitterAmount * 0.6;
                        offsetY = (noiseY - Math.floor(noiseY) - 0.5) * pathJitterAmount * 0.4;
                    }
                    break;
            }

            return {
                x: offsetX,
                y: offsetY
            };
        }

        // Function to get the bounds of a letter for fill effects
        function getLetterBounds(pathPoints, xOffset = 0, yOffset = 0) {
            if (!pathPoints || pathPoints.length === 0) return null;

            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

            for (const point of pathPoints) {
                const x = point.x - xOffset;
                const y = point.y - yOffset;
                minX = Math.min(minX, x);
                minY = Math.min(minY, y);
                maxX = Math.max(maxX, x);
                maxY = Math.max(maxY, y);
            }

            return {
                left: minX,
                top: minY,
                right: maxX,
                bottom: maxY,
                width: maxX - minX,
                height: maxY - minY
            };
        }

        // Check if there are any letters currently filling
        function hasActiveFillAnimations() {
            if (fillMode === 'none' || letterData.length === 0) return false;

            return letterData.some(letter => {
                if (!letter.drawingComplete || !letter.fillStartTime) return false;
                const fillDuration = 2000; // Same as in the fill code
                const fillElapsed = performance.now() - letter.fillStartTime;
                return fillElapsed < fillDuration;
            });
        }

        // Calculate path jitter offsets for a letter
        function calculatePathJitterOffsetsForLetter(letter, letterIndex) {
            if (!letter.pts || letter.pts.length === 0 || pathJitterAmount === 0) {
                return [];
            }

            const offsets = [];
            let cumulativeDistance = 0;
            const totalPathLength = letter.pts.length * 8; // Approximate path length

            // Check if this is a closed path for special sine handling
            const firstPoint = letter.pts[0];
            const lastPoint = letter.pts[letter.pts.length - 1];
            const distance = Math.sqrt(
                (lastPoint.x - firstPoint.x) ** 2 + (lastPoint.y - firstPoint.y) ** 2
            );
            const isClosedPath = distance < 0.1 || (distance < 10 && Math.abs(lastPoint.x - firstPoint.x) < 5 && Math.abs(lastPoint.y - firstPoint.y) < 5);

            for (let i = 0; i < letter.pts.length; i++) {
                if (i > 0) {
                    const dx = letter.pts[i].x - letter.pts[i - 1].x;
                    const dy = letter.pts[i].y - letter.pts[i - 1].y;
                    cumulativeDistance += Math.sqrt(dx * dx + dy * dy);
                }

                // Calculate path direction for better jitter (use wider span for stability)
                let pathDirection = null;
                if (i > 1 && i < letter.pts.length - 2) {
                    // Use points 2 steps away for more stable direction calculation
                    const dx = letter.pts[i + 2].x - letter.pts[i - 2].x;
                    const dy = letter.pts[i + 2].y - letter.pts[i - 2].y;
                    const length = Math.sqrt(dx * dx + dy * dy);
                    if (length > 0) {
                        pathDirection = { x: dx / length, y: dy / length };
                    }
                } else if (i > 0 && i < letter.pts.length - 1) {
                    // Fallback to adjacent points for edge cases
                    const dx = letter.pts[i + 1].x - letter.pts[i - 1].x;
                    const dy = letter.pts[i + 1].y - letter.pts[i - 1].y;
                    const length = Math.sqrt(dx * dx + dy * dy);
                    if (length > 0) {
                        pathDirection = { x: dx / length, y: dy / length };
                    }
                }

                // For closed paths and sine-based waves, ensure the last point uses distance 0 to match start
                let adjustedDistance = cumulativeDistance;
                if (isClosedPath && i === letter.pts.length - 1 &&
                    (pathJitterShape === 'sine' || pathJitterShape === 'cosine' || pathJitterShape === 'abs-sine')) {
                    adjustedDistance = 0; // Force last point to use same phase as first point
                }

                const jitterOffset = calculatePathJitter(
                    adjustedDistance,
                    i,
                    totalPathLength,
                    letterIndex,
                    1.0,
                    pathDirection
                );

                offsets.push(jitterOffset);
            }

            // Ensure closed paths: match start/end points that are identical or very close
            if (offsets.length > 2) {
                const firstPoint = letter.pts[0];
                const lastPoint = letter.pts[letter.pts.length - 1];

                // Check if last point is exactly the same or very close to first point
                const distance = Math.sqrt(
                    (lastPoint.x - firstPoint.x) ** 2 + (lastPoint.y - firstPoint.y) ** 2
                );

                // For closed paths, ensure smooth transition back to start
                if (distance < 0.1 || (distance < 10 && Math.abs(lastPoint.x - firstPoint.x) < 5 && Math.abs(lastPoint.y - firstPoint.y) < 5)) {
                    // For sine and cosine waves, the natural calculation should provide continuity
                    // Only apply easing for non-continuous waveforms
                    if (pathJitterShape === 'sine' || pathJitterShape === 'cosine' || pathJitterShape === 'abs-sine') {
                        // For sine-based waves, the last point should already match the first due to adjustedDistance = 0
                        // Just ensure exact match without additional easing
                        offsets[offsets.length - 1] = { ...offsets[0] };
                    } else {
                        // For other wave shapes (triangle, square, sawtooth, noise), apply easing
                        offsets[offsets.length - 1] = { ...offsets[0] };

                        const easeLength = Math.min(Math.floor(offsets.length * 0.3), 15);

                        if (offsets.length > easeLength * 2 && easeLength > 1) {
                            const targetOffset = offsets[0];

                            for (let k = 1; k < easeLength; k++) {
                                const endIndex = offsets.length - 1 - k;
                                if (endIndex > 0 && endIndex < offsets.length - 1) {
                                    const normalizedK = k / easeLength;
                                    const sineEase = Math.sin(normalizedK * Math.PI * 0.5);
                                    const easeFactor = 1 - sineEase;

                                    offsets[endIndex] = {
                                        x: offsets[endIndex].x * easeFactor + targetOffset.x * (1 - easeFactor),
                                        y: offsets[endIndex].y * easeFactor + targetOffset.y * (1 - easeFactor)
                                    };
                                }
                            }
                        }
                    }
                }

                // Enhanced matching for all identical coordinates throughout the path
                for (let i = 0; i < letter.pts.length; i++) {
                    const currentPoint = letter.pts[i];

                    // Check all subsequent points for identical coordinates
                    for (let j = i + 1; j < letter.pts.length; j++) {
                        const comparePoint = letter.pts[j];

                        // Check for exact coordinate match (floating point precision)
                        if (Math.abs(comparePoint.x - currentPoint.x) < 0.01 && Math.abs(comparePoint.y - currentPoint.y) < 0.01) {
                            offsets[j] = { ...offsets[i] };
                        }
                    }
                }
            }

            return offsets;
        }

        // Recalculate path jitter offsets for all revealed letters
        function recalculatePathJitterOffsets() {
            if (letterData.length === 0) return;

            for (let i = 0; i < letterData.length; i++) {
                const letter = letterData[i];
                if (letter.revealed && pathJitterAmount > 0 && letter.pts && letter.pts.length > 0) {
                    letter.pathJitterOffsets = calculatePathJitterOffsetsForLetter(letter, i);
                }
            }
        }

        // Help modal functionality
        function initializeHelpModal() {
            const helpButton = document.getElementById('helpButton');
            const helpModal = document.getElementById('helpModal');
            const helpCloseButton = document.getElementById('helpCloseButton');

            // Open help modal
            helpButton.addEventListener('click', function () {
                helpModal.classList.add('show');
            });

            // Close help modal
            helpCloseButton.addEventListener('click', function () {
                helpModal.classList.remove('show');
            });

            // Close modal when clicking outside the content
            helpModal.addEventListener('click', function (e) {
                if (e.target === helpModal) {
                    helpModal.classList.remove('show');
                }
            });

            // Close modal with Escape key
            document.addEventListener('keydown', function (e) {
                if (e.key === 'Escape' && helpModal.classList.contains('show')) {
                    helpModal.classList.remove('show');
                }
            });
        }

        // Initialize the application when the page loads
        window.addEventListener('DOMContentLoaded', function () {
            init();
            initializeHelpModal();
        });
    </script>
</body>

</html>
